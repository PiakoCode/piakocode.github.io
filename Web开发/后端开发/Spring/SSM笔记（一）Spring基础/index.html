
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://piakocode.github.io/Web%E5%BC%80%E5%8F%91/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Spring/SSM%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Spring%E5%9F%BA%E7%A1%80/">
      
      
        <link rel="prev" href="../Mybatis/">
      
      
        <link rel="next" href="../SSM%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89SpringSecurity%E5%9F%BA%E7%A1%80/">
      
      
      <link rel="icon" href="../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>SSM笔记（一）Spring基础 - Piako's notebook</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#spring" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="Piako&#39;s notebook" class="md-header__button md-logo" aria-label="Piako's notebook" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Piako's notebook
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              SSM笔记（一）Spring基础
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../Read%20List/" class="md-tabs__link">
        
  
    
  
  Read List

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="md-tabs__link">
        
  
    
  
  学习经验

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" class="md-tabs__link">
        
  
    
  
  毕业设计

      </a>
    </li>
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="md-tabs__link">
          
  
  AI

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../Algorithm/ICPC%20%E6%A8%A1%E6%9D%BF/" class="md-tabs__link">
          
  
  Algorithm

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../Misc/RPC%E5%AD%A6%E4%B9%A0/" class="md-tabs__link">
          
  
  Misc

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../System/System/" class="md-tabs__link">
          
  
  System

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../../Linux%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="md-tabs__link">
          
  
  Web开发

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../%E5%85%B6%E4%BB%96/CMU15445/CMU-15-445-spring2023%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" class="md-tabs__link">
          
  
  其他

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Bash%20%E8%84%9A%E6%9C%AC/" class="md-tabs__link">
          
  
  工具使用

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/C%2B%2B%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B/" class="md-tabs__link">
          
  
  编程语言

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Piako&#39;s notebook" class="md-nav__button md-logo" aria-label="Piako's notebook" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Piako's notebook
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Read%20List/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Read List
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习经验
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    毕业设计
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    AI
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            AI
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1" >
        
          
          <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    机器学习
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1">
            <span class="md-nav__icon md-icon"></span>
            机器学习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    机器学习
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    机器学习实战
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    机器学习（二）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1_4" >
        
          
          <label class="md-nav__link" for="__nav_5_1_4" id="__nav_5_1_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    常用库
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1_4">
            <span class="md-nav__icon md-icon"></span>
            常用库
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/Keras/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Keras
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/numpy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    numpy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/opencv/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    opencv
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/pandas%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    pandas 基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1_4_5" >
        
          
          <label class="md-nav__link" for="__nav_5_1_4_5" id="__nav_5_1_4_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Matplotlib
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_1_4_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1_4_5">
            <span class="md-nav__icon md-icon"></span>
            Matplotlib
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/matplotlib/matplotlib/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    matplotlib
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1_4_6" >
        
          
          <label class="md-nav__link" for="__nav_5_1_4_6" id="__nav_5_1_4_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Seaborn
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_1_4_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1_4_6">
            <span class="md-nav__icon md-icon"></span>
            Seaborn
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/seaborn/seaborn/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    seaborn
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1_4_7" >
        
          
          <label class="md-nav__link" for="__nav_5_1_4_7" id="__nav_5_1_4_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sklearn
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_1_4_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1_4_7">
            <span class="md-nav__icon md-icon"></span>
            Sklearn
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/sklearn/sklearn%20%E5%85%A5%E9%97%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sklearn 入门
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E7%94%A8%E5%BA%93/sklearn/sklearn%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SKlearn 常用代码
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    深度学习
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            深度学习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Code-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Code-人工智能
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pytorch 使用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    深度学习
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_4" >
        
          
          <label class="md-nav__link" for="__nav_5_2_4" id="__nav_5_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CV
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2_4">
            <span class="md-nav__icon md-icon"></span>
            CV
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_4_1" >
        
          
          <label class="md-nav__link" for="__nav_5_2_4_1" id="__nav_5_2_4_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Yolo
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_2_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2_4_1">
            <span class="md-nav__icon md-icon"></span>
            Yolo
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CV/yolo/yolo%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    yoloV5基本介绍
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_5" >
        
          
          <label class="md-nav__link" for="__nav_5_2_5" id="__nav_5_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    卷积神经网络
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2_5">
            <span class="md-nav__icon md-icon"></span>
            卷积神经网络
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    卷积神经网络基础
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3" >
        
          
          <label class="md-nav__link" for="__nav_5_3" id="__nav_5_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    遇到的问题
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_3">
            <span class="md-nav__icon md-icon"></span>
            遇到的问题
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../AI/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/%E7%BC%96%E7%A8%8B%E7%BB%86%E8%8A%82%E7%9B%B8%E5%85%B3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    编程细节相关
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Algorithm
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Algorithm
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/ICPC%20%E6%A8%A1%E6%9D%BF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ICPC 模板
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    动态规划
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%F0%9F%A7%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tricks
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_4" >
        
          
          <label class="md-nav__link" for="__nav_6_4" id="__nav_6_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    做题记录💭💡🎈
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_4">
            <span class="md-nav__icon md-icon"></span>
            做题记录💭💡🎈
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/ACwing%E9%A2%98%E9%9B%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ACwing题集
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_4_2" >
        
          
          <label class="md-nav__link" for="__nav_6_4_2" id="__nav_6_4_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    ACwing
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_6_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_4_2">
            <span class="md-nav__icon md-icon"></span>
            ACwing
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/ACwing/1499%20%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    树的遍历 1499
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/ACwing/284%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    284 石子合并
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_4_3" >
        
          
          <label class="md-nav__link" for="__nav_6_4_3" id="__nav_6_4_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Codeforces
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_6_4_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_4_3">
            <span class="md-nav__icon md-icon"></span>
            Codeforces
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/Codeforces/1307D/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BFS #图论 #Codeforces
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_4_4" >
        
          
          <label class="md-nav__link" for="__nav_6_4_4" id="__nav_6_4_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    洛谷
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_6_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_4_4">
            <span class="md-nav__icon md-icon"></span>
            洛谷
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/%E6%B4%9B%E8%B0%B7/P1119%20%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    P1119 灾后重建
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Algorithm/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%F0%9F%92%AD%F0%9F%92%A1%F0%9F%8E%88/%E6%B4%9B%E8%B0%B7/P5076%20%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二叉树 #二叉搜索树
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Misc
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Misc
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/RPC%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RPC学习
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/Record/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Record
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/Todo%20List/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TODO LIST
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/mermaid/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    mermaid
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/obsidian%20%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Obsidian 好用的插件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    各种配置文件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/%E5%B0%8F%E8%AE%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    小记
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Misc/%E8%80%83%E7%A0%94%E9%99%A2%E6%A0%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    考研院校记录
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    System
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            System
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/System/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/%E5%B9%B6%E5%8F%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    并发
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_3" >
        
          
          <label class="md-nav__link" for="__nav_8_3" id="__nav_8_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    RISC V
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_3">
            <span class="md-nav__icon md-icon"></span>
            RISC V
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/RISC-V/RISC-V/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RISC-V
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/RISC-V/%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RISC-V基本指令
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/RISC-V/%E6%B5%8B%E8%AF%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    测试
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_4" >
        
          
          <label class="md-nav__link" for="__nav_8_4" id="__nav_8_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    rCore
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_4">
            <span class="md-nav__icon md-icon"></span>
            rCore
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/rCore/ch0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ch0
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/rCore/ch1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ch1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/rCore/ch5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ch5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_4_4" >
        
          
          <label class="md-nav__link" for="__nav_8_4_4" id="__nav_8_4_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    rCore学习记录
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_8_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_4_4">
            <span class="md-nav__icon md-icon"></span>
            rCore学习记录
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../System/rCore/rCore%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/rCore%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习记录
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Web开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            Web开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" >
        
          
          <label class="md-nav__link" for="__nav_9_1" id="__nav_9_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Linux编程
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_1">
            <span class="md-nav__icon md-icon"></span>
            Linux编程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Linux%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    epoll
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Linux%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux 网络编程
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Linux%E7%BC%96%E7%A8%8B/connect%E3%80%81listen%E5%92%8Caccept/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    connect、listen和accept
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Linux%E7%BC%96%E7%A8%8B/epoll/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    epoll
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Linux%E7%BC%96%E7%A8%8B/io_uring/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    io_uring
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1_6" >
        
          
          <label class="md-nav__link" for="__nav_9_1_6" id="__nav_9_1_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Linux Unix编程手册
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_9_1_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_1_6">
            <span class="md-nav__icon md-icon"></span>
            Linux Unix编程手册
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Linux%E7%BC%96%E7%A8%8B/Linux-Unix%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/1.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    基本概念
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_2" >
        
          
          <label class="md-nav__link" for="__nav_9_2" id="__nav_9_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    前端
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_2">
            <span class="md-nav__icon md-icon"></span>
            前端
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%89%8D%E7%AB%AF/CSS%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CSS基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%89%8D%E7%AB%AF/HTML%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HTML笔记
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前端基础
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3" checked>
        
          
          <label class="md-nav__link" for="__nav_9_3" id="__nav_9_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    后端开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9_3">
            <span class="md-nav__icon md-icon"></span>
            后端开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Java%E7%9A%84%E5%9D%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java的坑
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Jwt%E7%BB%93%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Jwt结构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    软件架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3_4" checked>
        
          
          <label class="md-nav__link" for="__nav_9_3_4" id="__nav_9_3_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Spring
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_9_3_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9_3_4">
            <span class="md-nav__icon md-icon"></span>
            Spring
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Mybatis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mybatis
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    SSM笔记（一）Spring基础
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SSM%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89SpringSecurity%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SSM笔记（三）SpringSecurity基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SSM%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89SpringMvc%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringMVC基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SpringMVC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringMVC
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SpringSecurity/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringSecurity
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../spring/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Spring
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    图书管理系统
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3_5" >
        
          
          <label class="md-nav__link" for="__nav_9_3_5" id="__nav_9_3_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    SpringBoot
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_9_3_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_3_5">
            <span class="md-nav__icon md-icon"></span>
            SpringBoot
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringBoot/SpringBoot/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringBoot
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringBoot/SpringBoot%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringBoot笔记（一）核心内容
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringBoot/SpringBoot%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringBoot笔记（三）前后端分离
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringBoot/SpringBoot%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringBoot笔记（二）数据交互
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3_6" >
        
          
          <label class="md-nav__link" for="__nav_9_3_6" id="__nav_9_3_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    SpringCloud
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_9_3_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_3_6">
            <span class="md-nav__icon md-icon"></span>
            SpringCloud
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringCloud/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringCloud笔记（一）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringCloud/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    微服务应用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringCloud/SpringCloud%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringCloud笔记（四）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../SpringCloud/SpringCould%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SpringCould笔记（二）
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3_7" >
        
          
          <label class="md-nav__link" for="__nav_9_3_7" id="__nav_9_3_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Etcd
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_9_3_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_3_7">
            <span class="md-nav__icon md-icon"></span>
            Etcd
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../etcd/etcd%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    etcd基本使用
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3_8" >
        
          
          <label class="md-nav__link" for="__nav_9_3_8" id="__nav_9_3_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Gin
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_9_3_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_3_8">
            <span class="md-nav__icon md-icon"></span>
            Gin
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../gin/Gin%20%2B%20Gorm/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gin + Gorm
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../gin/Gin-Gorm-Todo_List/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Todo-List
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../gin/Gin/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gin
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../gin/Gin%E6%A0%B7%E4%BE%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gin样例
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../gin/Gorm%E6%A0%B7%E4%BE%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gorm样例
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../gin/%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    上传、下载文件
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_4" >
        
          
          <label class="md-nav__link" for="__nav_9_4" id="__nav_9_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数据库
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_4">
            <span class="md-nav__icon md-icon"></span>
            数据库
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%95%B0%E6%8D%AE%E5%BA%93/build%20a%20simple%20database/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    build a simple database
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          <label class="md-nav__link" for="__nav_10" id="__nav_10_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    其他
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            其他
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_1" >
        
          
          <label class="md-nav__link" for="__nav_10_1" id="__nav_10_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CMU15445
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_1">
            <span class="md-nav__icon md-icon"></span>
            CMU15445
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CMU15445/CMU-15-445-spring2023%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CMU15445通关记录
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_2" >
        
          
          <label class="md-nav__link" for="__nav_10_2" id="__nav_10_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CSAPP
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_2">
            <span class="md-nav__icon md-icon"></span>
            CSAPP
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/3.%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    程序的机器级表示
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/bomb%20lab/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bomb lab
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/data%20lab/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Data lab
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/%E5%BC%82%E5%B8%B8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    异常
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    虚拟内存
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/%E9%93%BE%E6%8E%A5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    链接
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_2_7" >
        
          
          <label class="md-nav__link" for="__nav_10_2_7" id="__nav_10_2_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CMU15 455
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_10_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_2_7">
            <span class="md-nav__icon md-icon"></span>
            CMU15 455
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/CSAPP/CMU15-455/CMU15-455/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CMU15-455
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_3" >
        
          
          <label class="md-nav__link" for="__nav_10_3" id="__nav_10_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    MIT6.S081 操作系统
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_3">
            <span class="md-nav__icon md-icon"></span>
            MIT6.S081 操作系统
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/MIT6.S081%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%20Lab%20Utilities/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1. Lab Utilities
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/MIT6.S081%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%20Lab%20system%20calls/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab: system calls
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/MIT6.S081%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%20Lab%20page%20tables/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab: page tables
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/MIT6.S081%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%20Lab%20Traps/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lab: Traps
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/MIT6.S081%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%20Lab/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7. Lab
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_4" >
        
          
          <label class="md-nav__link" for="__nav_10_4" id="__nav_10_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    NJU OS
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_4">
            <span class="md-nav__icon md-icon"></span>
            NJU OS
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/NJU%20OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    操作系统
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_5" >
        
          
          <label class="md-nav__link" for="__nav_10_5" id="__nav_10_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    OSTEP
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_5">
            <span class="md-nav__icon md-icon"></span>
            OSTEP
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/OSTEP/OSTEP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OSTEP读书笔记
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_6" >
        
          
          <label class="md-nav__link" for="__nav_10_6" id="__nav_10_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算机网络
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_6">
            <span class="md-nav__icon md-icon"></span>
            计算机网络
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%20%E6%A6%82%E8%AE%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概论
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CS144
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%85%B6%E4%BB%96/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    计算机网络
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          <label class="md-nav__link" for="__nav_11" id="__nav_11_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    工具使用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            工具使用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Bash%20%E8%84%9A%E6%9C%AC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bash 脚本
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/CMake/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CMake
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Doxygen/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Doxygen
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Helix/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Helix
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Hyprland%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    hyprland配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Linux%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux笔记
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Make/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Make使用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/MongoDB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MongoDB
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/MySQL%E6%8C%87%E4%BB%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MySQL指令
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Nginx/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Nginx
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Redis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Redis使用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Vim/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vim
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/docker/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    docker 使用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gdb常用命令
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/tmux/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tmux
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%B8%B8%E7%94%A8Latex%E7%AC%A6%E5%8F%B7%E5%85%AC%E5%BC%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    常用Latex符号公式
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%B8%B8%E7%94%A8git%E6%8C%87%E4%BB%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    常用git指令
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          <label class="md-nav__link" for="__nav_12" id="__nav_12_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    编程语言
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            编程语言
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_1" >
        
          
          <label class="md-nav__link" for="__nav_12_1" id="__nav_12_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    C++
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_12_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_1">
            <span class="md-nav__icon md-icon"></span>
            C++
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/C%2B%2B%E4%BB%A3%E7%A0%81%E6%A0%B7%E4%BE%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++-Code
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/C%2B%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reactor
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/GTest/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GTest
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/Google%20benchmark/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Google benchmark
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/clang-format%20%20%26%20clang-tidy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    clang-format &amp; clang-tidy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_1_6" >
        
          
          <label class="md-nav__link" for="__nav_12_1_6" id="__nav_12_1_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    语法
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_12_1_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_1_6">
            <span class="md-nav__icon md-icon"></span>
            语法
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/%E8%AF%AD%E6%B3%95/C%2B%2B%20Template/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++ Template
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/%E8%AF%AD%E6%B3%95/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%2B%2B/%E8%AF%AD%E6%B3%95/C%2B%2B%E5%BA%93%E5%87%BD%E6%95%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++ 库函数
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_2" >
        
          
          <label class="md-nav__link" for="__nav_12_2" id="__nav_12_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    C语言
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_12_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_2">
            <span class="md-nav__icon md-icon"></span>
            C语言
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C语言
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C语言并发编程
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C的编译
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ELF文件结构
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_3" >
        
          
          <label class="md-nav__link" for="__nav_12_3" id="__nav_12_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Go
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_12_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_3">
            <span class="md-nav__icon md-icon"></span>
            Go
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go-tricks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go-tricks
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go基础语法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go%E5%B9%B6%E5%8F%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    并发
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/Go%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Standard Go Project Layout
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/jwt-go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    jwt-go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/protobuf%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    protobuf使用
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_4" >
        
          
          <label class="md-nav__link" for="__nav_12_4" id="__nav_12_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Java
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_12_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_4">
            <span class="md-nav__icon md-icon"></span>
            Java
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java-OI%E6%B5%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    JavaOI流
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/linux%E5%AE%89%E8%A3%85mysql/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux安装mysql
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_5" >
        
          
          <label class="md-nav__link" for="__nav_12_5" id="__nav_12_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Rust
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_12_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_5">
            <span class="md-nav__icon md-icon"></span>
            Rust
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/Cargo/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Cargo
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/Rust-Code/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust Code
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/rust%E8%AE%B0%E5%BD%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust记录
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/simple%20but%20useful%20code/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    代码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_5_5" >
        
          
          <label class="md-nav__link" for="__nav_12_5_5" id="__nav_12_5_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    语法
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_12_5_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12_5_5">
            <span class="md-nav__icon md-icon"></span>
            语法
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/0.%E5%AE%89%E8%A3%85Rust%E5%92%8CHello%2CWorld/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    安装Rust和Hello,World
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/1.Rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust基本语法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/10.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    生命周期
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/11.%E9%97%AD%E5%8C%85%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    闭包和迭代器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/12.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    智能指针
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/13.%E5%B9%B6%E5%8F%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    并发
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/14.%20%E8%BF%9B%E9%98%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    进阶
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/2.%E6%89%80%E6%9C%89%E6%9D%83/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    所有权
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/3.%E7%BB%93%E6%9E%84%E4%BD%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    结构体
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/4.%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    枚举和模式匹配
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/5.%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%28Vec%E3%80%81string%E3%80%81map%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    常见集合
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/6.%E6%A8%A1%E5%9D%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    模块 Crate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/7.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    错误处理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/8.%E6%B3%9B%E5%9E%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    泛型
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/9.Trait/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Trait
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E8%AF%AD%E6%B3%95/%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8Bweb%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建多线程web服务器
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a class="glightbox" href="https://s2.loli.net/2022/10/08/ZsKlOvz5xmXSutw.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221008182958877" src="https://s2.loli.net/2022/10/08/ZsKlOvz5xmXSutw.png" /></a></p>
<h1 id="spring">Spring核心技术<a class="headerlink" href="#spring" title="Permanent link">&para;</a></h1>
<h1 id="java-spring">java #spring<a class="headerlink" href="#java-spring" title="Permanent link">&para;</a></h1>
<p><strong>前置课程要求：</strong>请各位小伙伴先完成《JavaWeb》篇、《Java 9-17新特性》篇视频教程之后，再来观看此教程。</p>
<p><strong>建议：</strong>对Java开发还不是很熟悉的同学，最好先花费半个月到一个月时间大量地去编写小项目，不推荐一口气学完，后面的内容相比前面的内容几乎是降维打击，一口气学完很容易忘记之前所学的基础知识，尤其是JavaSE阶段的内容。</p>
<p><strong>不同于2021版本SSM教程，本期视频为重制版本，视频学习的Spring框架版本为：6.0</strong></p>
<p>恭喜各位顺利进入到SSM（Spring+SpringMVC+Mybatis）阶段的学习，也算是成功出了Java新手村，由于前面我们已经学习过Mybatis了，因此，本期教程的时间安排相比之前会更短一些。从这里开始，很多的概念理解起来就稍微有一点难度了，因为你们没有接触过企业开发场景，很难体会到那种思想带来的好处，甚至到后期接触到的几乎都是基于云计算和大数据理论实现的框架（当下最热门最前沿的技术）逐渐不再是和计算机基础相关联，而是和怎么高效干活相关了。</p>
<p>在JavaWeb阶段，我们已经学习了如何使用Java进行Web应用程序开发，我们现在已经具有搭建Web网站的能力，但是，我们在开发的过程中，发现存在诸多的不便，在最后的图书管理系统编程实战中，我们发现虽然我们思路很清晰，知道如何编写对应的接口，但是这样的开发效率，实在是太慢了，并且对于对象创建的管理，存在诸多的不妥之处，因此，我们要去继续学习更多的框架技术，来简化和规范我们的Java开发。</p>
<p>Spring就是这样的一个框架（文档：<a href="https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core">https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core</a>），它就是为了简化开发而生，它是轻量级的<strong>IoC</strong>和<strong>AOP</strong>的容器框架，主要是针对<strong>Bean</strong>的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。那么，首先一问，什么是<strong>IoC</strong>和<strong>AOP</strong>，什么又是<strong>Bean</strong>呢？不要害怕，这些概念只是听起来满满的高级感，实际上没有多高级（很多东西都是这样，名字听起来很牛，实际上只是一个很容易理解的东西）</p>
<h2 id="ioc">IoC容器基础<a class="headerlink" href="#ioc" title="Permanent link">&para;</a></h2>
<p>Spring框架最核心的其实它的IoC容器，这是我们开启Spring学习的第一站。</p>
<h3 id="ioc_1">IoC理论介绍<a class="headerlink" href="#ioc_1" title="Permanent link">&para;</a></h3>
<p>在我们之前的图书管理系统Web应用程序中，我们发现，整个程序其实是依靠各个部分相互协作，共同完成一个操作，比如要展示借阅信息列表，那么首先需要使用Servlet进行请求和响应的数据处理，然后请求的数据全部交给对应的Service（业务层）来处理，当Service发现要从数据库中获取数据时，再向对应的Mapper发起请求。</p>
<p>它们之间就像连接在一起的齿轮，谁也离不开谁：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/10/08/YQRP2idIS5skHJ4.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="img" src="https://s2.loli.net/2022/10/08/YQRP2idIS5skHJ4.png" /></a></p>
<p>就像一个团队，每个人的分工都很明确，流水线上的一套操作必须环环相扣，这是一种高度耦合的体系。</p>
<p>虽然这样的体系逻辑非常清晰，整个流程也能够让人快速了解，但是这样存在一个很严重的问题，我们现在的时代实际上是一个软件项目高速迭代的时代，我们发现很多App三天两头隔三差五地就更新，而且是什么功能当下最火，就马不停蹄地进行跟进开发，因此，就很容易出现，之前写好的代码，实现的功能，需要全部推翻，改成新的功能，那么我们就不得不去修改某些流水线上的模块，但是这样一修改，会直接导致整个流水线的引用关系大面积更新。</p>
<p>比如下面的情况：</p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">C</span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">C</span><span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">){}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">B</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>可以看到，A和C在大量地直接使用B，但是某一天，这个B的实现已经过时了，此时来了个把功能实现的更好的D，我们需要用这个新的类来完成业务了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/FRQn6vEpTklsJKe.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122135859871" src="https://s2.loli.net/2022/11/22/FRQn6vEpTklsJKe.png" /></a></p>
<p>可以看到，因为类之间的关联性太强了，会开始大面积报错，所有之前用了B的类，得挨个进行修改，全都改成D，这简直是灾难啊！</p>
<p>包括我们之前JavaWeb阶段编写的实战项目，如果我们不想用某个Service实现类了，我想使用其他的实现类用不同的逻辑做这些功能，那么这个时候，我们只能每个类都去挨个进行修改，当项目特别庞大时，光是改个类名导致的连带修改就够你改一天了。</p>
<p>因此，高耦合度带来的缺点是很明显的，也是现代软件开发中很致命的问题。如果要改善这种情况，我们只能将各个模块进行解耦，让各个模块之间的依赖性不再那么地强。也就是说，Service的实现类，不再由我们决定，而是让程序自己决定，所有的实现类对象，全部交给程序来管理，所有对象之间的关系，也由程序来动态决定，这样就引入了IoC理论。</p>
<p>IOC是Inversion of Control的缩写，翻译为：“控制反转”，把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/10/08/XsYQRk93CHewISB.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="img" src="https://s2.loli.net/2022/10/08/XsYQRk93CHewISB.png" /></a></p>
<p>我们可以将对象交给IoC容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类，能用就完事了，反正接口定义了啥，我只管调，这样，我们就可以放心地让一个人去写视图层的代码，一个人去写业务层的代码，开发效率那是高的一匹啊。</p>
<p>还是之前的代码，但是有了IoC容器加持之后：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">();</span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="na">test</span><span class="p">(</span><span class="n">IoC</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Service</span><span class="p">.</span><span class="na">class</span><span class="p">));</span><span class="w">   </span><span class="c1">//瞎编的一个容器类，但是是那个意思</span>
<span class="w">    </span><span class="c1">//比如现在在IoC容器中管理的Service的实现是B，那么我们从里面拿到的Service实现就是B</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Service</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">   </span><span class="c1">//一律使用Service，具体实现由IoC容器提供</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="n">Service</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">interface</span> <span class="nc">Service</span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">//使用Service做一个顶层抽象</span>

<span class="kd">class</span> <span class="nc">B</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Service</span><span class="p">{}</span><span class="w">  </span><span class="c1">//B依然是具体实现类，并交给IoC容器管理</span>
</code></pre></div>
<p>当具体实现类发生修改时，我们同样只需要将新的实现类交给IoC容器管理，这样我们无需修改之前的任何代码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">interface</span> <span class="nc">Service</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="kd">class</span> <span class="nc">D</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Service</span><span class="p">{}</span><span class="w">   </span><span class="c1">//现在实现类变成了D，但是之前的代码并不会报错</span>
</code></pre></div>
<p>这样，即使我们的底层实现类发生了修改，也不会导致与其相关联的类出现错误，而进行大面积修改，通过定义抽象+容器管理的形式，我们就可以将原有的强关联解除。</p>
<p>高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理，一个由Spring IoC容器实例化、组装和管理的对象，我们称其为Bean。</p>
<h3 id="spring_1">第一个Spring项目<a class="headerlink" href="#spring_1" title="Permanent link">&para;</a></h3>
<p>首先一定要明确，使用Spring首要目的是为了使得软件项目进行解耦，而不是为了去简化代码！通过它，就可以更好的对我们的Bean进行管理，这一部分我们来体验一下Spring的基本使用。</p>
<p>Spring并不是一个独立的框架，它实际上包含了很多的模块：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/21/KT2XhuCNVmcSvi5.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221121233807593" src="https://s2.loli.net/2022/11/21/KT2XhuCNVmcSvi5.png" /></a></p>
<p>而我们首先要去学习的就是Core Container，也就是核心容器模块，只有了解了Spring的核心技术，我们才能真正认识这个框架为我们带来的便捷之处。</p>
<p>Spring是一个非入侵式的框架，就像一个工具库一样，它可以很简单地加入到我们已有的项目中，因此，我们只需要直接导入其依赖就可以使用了，Spring核心框架的Maven依赖坐标：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>spring-context<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>6.0.10<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p><strong>注意：</strong>与旧版教程不同的是，Spring 6要求你使用的Java版本为<code>17</code>及以上，包括后面我们在学习SpringMvc时，要求Tomcat版本必须为10以上。这个依赖中包含了如下依赖：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/HszTflPavUdQKGJ.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122133820198" src="https://s2.loli.net/2022/11/22/HszTflPavUdQKGJ.png" /></a></p>
<p>这里出现的都是Spring核心相关的内容，如Beans、Core、Context、SpEL以及非常关键的AOP框架，在本章中，我们都会进行讲解。</p>
<blockquote>
<p>如果在使用Spring框架的过程中出现如下警告：</p>
<div class="highlight"><pre><span></span><code>12月 17, 2022 3:26:26 下午 org.springframework.core.LocalVariableTableParameterNameDiscoverer inspectClass
警告: Using deprecated &#39;-debug&#39; fallback for parameter name resolution. Compile the affected code with &#39;-parameters&#39; instead or avoid its introspection: XXXX
</code></pre></div>
<p>这是因为LocalVariableTableParameterNameDiscoverer在Spring 6.0.1版本已经被标记为过时，并且即将移除，请在Maven配置文件中为编译插件添加<code>-parameters</code>编译参数：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;build&gt;</span>
<span class="w">    </span><span class="nt">&lt;pluginManagement&gt;</span>
<span class="w">        </span><span class="nt">&lt;plugins&gt;</span>
<span class="w">            </span><span class="nt">&lt;plugin&gt;</span>
<span class="w">                </span><span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">                </span><span class="nt">&lt;version&gt;</span>3.10.1<span class="nt">&lt;/version&gt;</span>
<span class="w">                </span><span class="nt">&lt;configuration&gt;</span>
<span class="w">                    </span><span class="nt">&lt;compilerArgs&gt;</span>
<span class="w">                        </span><span class="nt">&lt;arg&gt;</span>-parameters<span class="nt">&lt;/arg&gt;</span>
<span class="w">                    </span><span class="nt">&lt;/compilerArgs&gt;</span>
<span class="w">                </span><span class="nt">&lt;/configuration&gt;</span>
<span class="w">            </span><span class="nt">&lt;/plugin&gt;</span>
<span class="w">        </span><span class="nt">&lt;/plugins&gt;</span>
<span class="w">    </span><span class="nt">&lt;/pluginManagement&gt;</span>
<span class="nt">&lt;/build&gt;</span>
</code></pre></div>
<p>没有此问题请无视这部分。</p>
</blockquote>
<p>这里我们就来尝试编写一个最简的Spring项目，我们在前面已经讲过了，Spring会给我们提供IoC容器用于管理Bean，但是我们得先为这个容器编写一个配置文件，我们可以通过配置文件告诉容器需要管理哪些Bean以及Bean的属性、依赖关系等等。</p>
<p>首先我们需要在resource中创建一个Spring配置文件（在resource中创建的文件，会在编译时被一起放到类路径下），命名为test.xml，直接右键点击即可创建：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;beans</span><span class="w"> </span><span class="na">xmlns=</span><span class="s">&quot;http://www.springframework.org/schema/beans&quot;</span>
<span class="w">       </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w">       </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.springframework.org/schema/beans</span>
<span class="s">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div>
<p>此时IDEA会提示我们没有为此文件配置应用程序上下文，这里我们只需要指定成当前项目就行了，当然配置这个只是为了代码提示和依赖关系快速查看，如果不进行配置也不会影响什么，程序依然可以正常运行：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/21/bBtrSWlVz9oD2JF.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221121234427739" src="https://s2.loli.net/2022/11/21/bBtrSWlVz9oD2JF.png" /></a></p>
<p>这里我们直接按照默认配置点确定就行了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/21/xoatfu4nX6iRr3v.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221121234447213" src="https://s2.loli.net/2022/11/21/xoatfu4nX6iRr3v.png" /></a></p>
<p>Spring为我们提供了一个IoC容器，用于去存放我们需要使用的对象，我们可以将对象交给IoC容器进行管理，当我们需要使用对象时，就可以向IoC容器去索要，并由它来决定给我们哪一个对象。而我们如果需要使用Spring为我们提供的IoC容器，那么就需要创建一个应用程序上下文，它代表的就是IoC容器，它会负责实例化、配置和组装Bean：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，这里我们先介绍第一种</span>
<span class="w">    </span><span class="c1">//因为这里使用的是XML配置文件，所以说我们就使用 ClassPathXmlApplicationContext 这个实现类</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;test.xml&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">//这里写上刚刚的名字</span>
<span class="p">}</span>
</code></pre></div>
<p>比如现在我们要让IoC容器帮助我们管理一个Student对象（Bean），当我们需要这个对象时再申请，那么就需要这样，首先先将Student类定义出来：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nn">com.test.bean</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>既然现在要让别人帮忙管理对象，那么就不能再由我们自己去new这个对象了，而是编写对应的配置，我们打开刚刚创建的<code>test.xml</code>文件进行编辑，添加：</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="n">bean</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="kd">class</span><span class="err">=&quot;</span><span class="nc">com</span><span class="p">.</span><span class="na">test</span><span class="p">.</span><span class="na">bean</span><span class="p">.</span><span class="na">Student</span><span class="s">&quot;/&gt;</span>
</code></pre></div>
<p>这里我们就在配置文件中编写好了对应Bean的信息，之后容器就会根据这里的配置进行处理了。</p>
<p>现在，这个对象不需要我们再去创建了，而是由IoC容器自动进行创建并提供，我们可以直接从上下文中获取到它为我们创建的对象：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;test.xml&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Student</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;student&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//使用getBean方法来获取对应的对象（Bean）</span>
<span class="w">    </span><span class="n">student</span><span class="p">.</span><span class="na">hello</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上，这里得到的Student对象是由Spring通过反射机制帮助我们创建的，初学者会非常疑惑，为什么要这样来创建对象，我们直接new一个它不香吗？为什么要交给IoC容器管理呢？在后面的学习中，我们再慢慢进行体会。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/sjLiFokU1f3CvH5.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122153946251" src="https://s2.loli.net/2022/11/22/sjLiFokU1f3CvH5.png" /></a></p>
<h3 id="bean">Bean注册与配置<a class="headerlink" href="#bean" title="Permanent link">&para;</a></h3>
<p>前面我们通过一个简单例子体验了一下如何使用Spring来管理我们的对象，并向IoC容器索要被管理的对象。这节课我们就来详细了解一下如何向Spring注册Bean以及Bean的相关配置。</p>
<p>实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;beans</span><span class="w"> </span><span class="err">...</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;import</span><span class="w"> </span><span class="na">resource=</span><span class="s">&quot;test.xml&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div>
<p>但是为了简单起见，我们还是从单配置文件开始讲起，首先我们需要知道如何配置Bean并注册。</p>
<p>要配置一个Bean，只需要添加：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean/&gt;</span>
</code></pre></div>
<p>但是这样写的话，Spring无法得知我们要配置的Bean到底是哪一个类，所以说我们还得指定对应的类才可以：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/SRV3znQJH4A7vDl.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122164149924" src="https://s2.loli.net/2022/11/22/SRV3znQJH4A7vDl.png" /></a></p>
<p>可以看到类的旁边出现了Bean的图标，表示我们的Bean已经注册成功了，这样，我们就可以根据类型向容器索要Bean实例对象了：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;test.xml&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//getBean有多种形式，其中第一种就是根据类型获取对应的Bean</span>
<span class="w">    </span><span class="c1">//容器中只要注册了对应类的Bean或是对应类型子类的Bean，都可以获取到</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">student</span><span class="p">.</span><span class="na">hello</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>不过在有些时候，Bean的获取可能会出现歧义，我们可以来分别注册两个子类的Bean：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ArtStudent</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Student</span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">art</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我爱画画&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SportStudent</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Student</span><span class="p">{</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sport</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我爱运动&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtStudent&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.SportStudent&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>但是此时我们在获取Bean时却是索要的它们的父类：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">student</span><span class="p">.</span><span class="na">hello</span><span class="p">();</span>
</code></pre></div>
<p>运行时得到如下报错：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/vliWJ4SZdx5E6yX.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122164100561" src="https://s2.loli.net/2022/11/22/vliWJ4SZdx5E6yX.png" /></a></p>
<p>这里出现了一个Bean定义不唯一异常，很明显，因为我们需要的类型是Student，但是此时有两个Bean定义都满足这个类型，它们都是Student的子类，此时IoC容器不知道给我们返回哪一个Bean，所以就只能抛出异常了。</p>
<p>因此，如果我们需要一个Bean并且使用类型进行获取，那么必须要指明类型并且不能出现歧义：</p>
<div class="highlight"><pre><span></span><code><span class="n">ArtStudent</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">ArtStudent</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">student</span><span class="p">.</span><span class="na">art</span><span class="p">();</span>
</code></pre></div>
<p>那要是两个Bean的类型都是一样的呢？</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="n">bean</span><span class="w"> </span><span class="kd">class</span><span class="err">=&quot;</span><span class="nc">com</span><span class="p">.</span><span class="na">test</span><span class="p">.</span><span class="na">bean</span><span class="p">.</span><span class="na">Student</span><span class="s">&quot;/&gt;</span>
<span class="s">&lt;bean class=&quot;</span><span class="n">com</span><span class="p">.</span><span class="na">test</span><span class="p">.</span><span class="na">bean</span><span class="p">.</span><span class="na">Student</span><span class="s">&quot;/&gt;</span>
</code></pre></div>
<p>这种情况下，就无法使用Class来进行区分了，除了为Bean指定对应类型之外，我们也可以为Bean指定一个名称用于区分：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;art&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtStudent&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;sport&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.SportStudent&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>name属性就是为这个Bean设定一个独一无二的名称（id属性也可以，跟name功能相同，但是会检查命名是否规范，否则会显示黄标），不同的Bean名字不能相同，否则报错：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样，这两个Bean我们就可以区分出来了：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Student</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span>
<span class="n">student</span><span class="p">.</span><span class="na">hello</span><span class="p">();</span>
</code></pre></div>
<p>虽然目前这两Bean定义都是一模一样的，也没什么区别，但是这确实是两个不同的Bean，只是类型一样而已，之后我们还可以为这两个Bean分别设置不同的其他属性。</p>
<p>我们可以给Bean起名字，也可以起别名，就行我们除了有一个名字之外，可能在家里还有自己的小名：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;alias</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="na">alias=</span><span class="s">&quot;test&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样，我们使用别名也是可以拿到对应的Bean的：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Student</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span>
<span class="n">student</span><span class="p">.</span><span class="na">hello</span><span class="p">();</span>
</code></pre></div>
<p>那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">Student</span><span class="w"> </span><span class="n">student2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">student2</span><span class="p">);</span><span class="w">   </span><span class="c1">//默认为单例模式，对象始终为同一个</span>
</code></pre></div>
<p>我们发现，最后得到的结果为true，那么说明每次从IoC容器获取到的对象，始终都是同一个，默认情况下，通过IoC容器进行管理的Bean都是单例模式的，这个对象只会被创建一次。</p>
<p>如果我们希望每次拿到的对象都是一个新的，我们也可以将其作用域进行修改：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122175719997" src="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png" /></a></p>
<p>这里一共有两种作用域，第一种是<code>singleton</code>，默认情况下就是这一种，当然还有<code>prototype</code>，表示为原型模式（为了方便叫多例模式也行）这种模式每次得到的对象都是一个新的：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span><span class="w">  </span><span class="c1">//原型模式下，对象不再始终是同一个了</span>
<span class="n">Student</span><span class="w"> </span><span class="n">student2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">student2</span><span class="p">);</span>
</code></pre></div>
<p>实际上，当Bean的作用域为单例模式时，那么它会在一开始（容器加载配置时）就被创建，我们之后拿到的都是这个对象。而处于原型模式下，只有在获取时才会被创建，也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接new了一个对象，并不会被保存。</p>
<p>当然，如果我们希望单例模式下的Bean不用再一开始就加载，而是一样等到需要时再加载（加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的）我们也可以开启懒加载：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">lazy-init=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>开启懒加载后，只有在真正第一次使用时才会创建对象。</p>
<p>因为单例模式下Bean是由IoC容器加载，但是加载顺序我们并不清楚，如果我们需要维护Bean的加载顺序（比如某个Bean必须要在另一个Bean之前创建）那么我们可以使用<code>depends-on</code>来设定前置加载Bean，这样被依赖的Bean一定会在之前加载，比如Teacher应该在Student之前加载：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Teacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">depends-on=</span><span class="s">&quot;teacher&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样就可以保证Bean的加载顺序了。</p>
<h3 id="_1">依赖注入<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。现在我们已经了解了如何注册和使用一个Bean，但是这样还远远不够，还记得我们一开始说的，消除类之间的强关联吗？比如现在有一个教师接口：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Teacher</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">teach</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>具体的实现有两个：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ArtTeacher</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Teacher</span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">teach</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是美术老师，我教你画画！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ProgramTeacher</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Teacher</span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">teach</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是编程老师，我教你学Golang！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>我们的学生一开始有一个老师教他，比如美术老师：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArtTeacher</span><span class="p">();</span><span class="w">   </span>
<span class="w">    </span><span class="c1">//在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">study</span><span class="p">(){</span>
<span class="w">        </span><span class="n">teacher</span><span class="p">.</span><span class="na">teach</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改Student类的定义：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ProgramTeacher</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>可以想象一下，如果现在冒出来各种各样的类都需要这样去用Teacher，那么一旦Teacher的实现发生变化，会导致我们挨个对之前用到Teacher的类进行修改，这就很难受了。</p>
<p>而有了依赖注入之后，Student中的Teacher成员变量，可以由IoC容器来选择一个合适的Teacher对象进行赋值，也就是说，IoC容器在创建对象时，需要将我们预先给定的属性注入到对象中，非常简单，我们可以使用<code>property</code>标签来实现，我们将bean标签展开：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ProgramTeacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;teacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>同时我们还需要修改一下Student类，依赖注入要求对应的属性必须有一个set方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setTeacher</span><span class="p">(</span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/wu2EYC8HToJbsva.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122191025279" src="https://s2.loli.net/2022/11/22/wu2EYC8HToJbsva.png" /></a></p>
<p>使用<code>property</code>来指定需要注入的值或是一个Bean，这里我们选择ProgramTeacher，那么在使用时，Student类中的得到的就是这个Bean的对象了：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">student</span><span class="p">.</span><span class="na">study</span><span class="p">();</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/n3zYWvIoE8CrRDT.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122191109690" src="https://s2.loli.net/2022/11/22/n3zYWvIoE8CrRDT.png" /></a></p>
<p>可以看到，现在我们的Java代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher都没出现）取而代之的是那一堆xml配置，这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下Bean的类型就可以：</p>
<div class="highlight"><pre><span></span><code><span class="cm">&lt;!--  只需要修改这里的class即可，现在改为ArtTeacher  --&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtTeacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;teacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>这样，这个Bean的class就变成了新的类型，并且我们不需要再去调整其他位置的代码，再次启动程序：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122191427776" src="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" /></a></p>
<p>通过依赖注入，是不是开始逐渐感受到Spring为我们带来的便利了？当然，依赖注入并不一定要注入其他的Bean，也可以是一个简单的值：</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="n">bean</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="kd">class</span><span class="err">=&quot;</span><span class="nc">com</span><span class="p">.</span><span class="na">test</span><span class="p">.</span><span class="na">bean</span><span class="p">.</span><span class="na">Student</span><span class="s">&quot;&gt;</span>
<span class="s">    &lt;property name=&quot;</span><span class="n">name</span><span class="s">&quot; value=&quot;</span><span class="n">卢本伟</span><span class="s">&quot;/&gt;</span>
<span class="s">&lt;/bean&gt;</span>
</code></pre></div>
<p>直接使用<code>value</code>可以直接传入一个具体值。</p>
<p>实际上，在很多情况下，类中的某些参数是在构造方法中就已经完成的初始化，而不是创建之后，比如：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span><span class="w">   </span><span class="c1">//构造方法中完成，所以说是一个final变量</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">){</span><span class="w">   </span><span class="c1">//Teacher属性是在构造方法中完成的初始化</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>我们前面说了，Bean实际上是由IoC容器进行创建的，但是现在我们修改了默认的无参构造，可以看到配置文件里面报错了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/5HN8GKQywWaYvrF.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122174328107" src="https://s2.loli.net/2022/11/22/5HN8GKQywWaYvrF.png" /></a></p>
<p>很明显，是因为我们修改了构造方法，IoC容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法，我们展开bean标签，添加一个<code>constructor-arg</code>标签：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtTeacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;constructor-arg</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;teacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>这里的<code>constructor-arg</code>就是构造方法的一个参数，这个参数可以写很多个，会自动匹配符合里面参数数量的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122191427776" src="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" /></a></p>
<p>通过这种方式，我们也能实现依赖注入，只不过现在我们将依赖注入的时机提前到了对象构造时。</p>
<p>那要是出现这种情况呢？现在我们的Student类中是这样定义的：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是一号构造方法&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是二号构造方法&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>此时我们希望使用的是二号构造方法，那么怎么才能指定呢？有2种方式，我们可以给标签添加类型：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;constructor-arg</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;int&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>也可以指定为对应的参数名称：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;constructor-arg</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;age&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>反正只要能够保证我们指定的参数匹配到目标构造方法即可。</p>
<p>现在我们的类中出现了一个比较特殊的类型，它是一个集合类型：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setList</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>对于这种集合类型，有着特殊的支持：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="cm">&lt;!--  对于集合类型，我们可以直接使用标签编辑集合的默认值  --&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;list&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;list&gt;</span>
<span class="w">            </span><span class="nt">&lt;value&gt;</span>AAA<span class="nt">&lt;/value&gt;</span>
<span class="w">            </span><span class="nt">&lt;value&gt;</span>BBB<span class="nt">&lt;/value&gt;</span>
<span class="w">            </span><span class="nt">&lt;value&gt;</span>CCC<span class="nt">&lt;/value&gt;</span>
<span class="w">        </span><span class="nt">&lt;/list&gt;</span>
<span class="w">    </span><span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>不仅仅是List，Map、Set这类常用集合类包括数组在内，都是支持这样编写的，比如Map类型，我们也可以使用<code>entry</code>来注入：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;map&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;map&gt;</span>
<span class="w">            </span><span class="nt">&lt;entry</span><span class="w"> </span><span class="na">key=</span><span class="s">&quot;语文&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;100.0&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;entry</span><span class="w"> </span><span class="na">key=</span><span class="s">&quot;数学&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;80.0&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;entry</span><span class="w"> </span><span class="na">key=</span><span class="s">&quot;英语&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;92.5&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/map&gt;</span>
<span class="w">    </span><span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>至此，我们就已经完成了两种依赖注入的学习：</p>
<ul>
<li>Setter依赖注入：通过成员属性对应的set方法完成注入。</li>
<li>构造方法依赖注入：通过构造方法完成注入。</li>
</ul>
<h3 id="_2">自动装配<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>在之前，如果我们需要使用依赖注入的话，我们需要对<code>property</code>参数进行配置：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;teacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>但是有些时候为了方便，我们也可以开启自动装配。自动装配就是让IoC容器自己去寻找需要填入的值，我们只需要将set方法提供好就可以了，这里需要添加autowire属性：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">autowire=</span><span class="s">&quot;byType&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p><code>autowire</code>属性有两个值普通，一个是byName，还有一个是byType，顾名思义，一个是根据类型去寻找合适的Bean自动装配，还有一个是根据名字去找，这样我们就不需要显式指定<code>property</code>了。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/QIBRwScq6fu4XDm.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122221936559" src="https://s2.loli.net/2022/11/22/QIBRwScq6fu4XDm.png" /></a></p>
<p>此时set方法旁边会出现一个自动装配图标，效果和上面是一样的。</p>
<p>对于使用构造方法完成的依赖注入，也支持自动装配，我们只需要将autowire修改为：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">autowire=</span><span class="s">&quot;constructor&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样，我们只需要提供一个对应参数的构造方法就可以了（这种情况默认也是byType寻找的）：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/rgl7fXJ2ZKAU8Rd.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122230320004" src="https://s2.loli.net/2022/11/22/rgl7fXJ2ZKAU8Rd.png" /></a></p>
<p>这样同样可以完成自动注入：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122191427776" src="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" /></a></p>
<p>自动化的东西虽然省事，但是太过机械，有些时候，自动装配可能会遇到一些问题，比如出现了下面的情况：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/22/SQTchJBq4G8NWyC.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221122223048820" src="https://s2.loli.net/2022/11/22/SQTchJBq4G8NWyC.png" /></a></p>
<p>此时，由于<code>autowire</code>的规则为byType，存在两个候选Bean，但是我们其实希望ProgramTeacher这个Bean在任何情况下都不参与到自动装配中，此时我们就可以将它的自动装配候选关闭：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtTeacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher2&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ProgramTeacher&quot;</span><span class="w"> </span><span class="na">autowire-candidate=</span><span class="s">&quot;false&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">autowire=</span><span class="s">&quot;byType&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>当<code>autowire-candidate</code>设定false时，这个Bean将不再作为自动装配的候选Bean，此时自动装配候选就只剩下一个唯一的Bean了，报错消失，程序可以正常运行。</p>
<p>除了这种方式，我们也可以设定primary属性，表示这个Bean作为主要的Bean，当出现歧义时，也会优先选择：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtTeacher&quot;</span><span class="w"> </span><span class="na">primary=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher2&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ProgramTeacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">autowire=</span><span class="s">&quot;byType&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样写程序依然可以正常运行，并且选择的也是ArtTeacher（就是不知道为什么IDEA会上红标，BUG？）</p>
<h3 id="_3">生命周期与继承<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>除了修改构造方法，我们也可以为Bean指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是对象初始化时要做的事情！&quot;</span><span class="p">);</span><span class="w">    </span>
<span class="p">}</span>

<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是对象销毁时要做的事情！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>我们可以通过<code>init-method</code>和<code>destroy-method</code>来指定：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="w"> </span><span class="na">init-method=</span><span class="s">&quot;init&quot;</span><span class="w"> </span><span class="na">destroy-method=</span><span class="s">&quot;destroy&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>那么什么时候是初始化，什么时候又是销毁呢？</p>
<div class="highlight"><pre><span></span><code><span class="c1">//当容器创建时，默认情况下Bean都是单例的，那么都会在一开始就加载好，对象构造完成后，会执行init-method</span>
<span class="n">ClassPathXmlApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;test.xml&quot;</span><span class="p">);</span>
<span class="c1">//我们可以调用close方法关闭容器，此时容器内存放的Bean也会被一起销毁，会执行destroy-method</span>
<span class="n">context</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</code></pre></div>
<p>所以说，最后的结果为：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/GWIyPDOaK4TAM1N.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123132604262" src="https://s2.loli.net/2022/11/23/GWIyPDOaK4TAM1N.png" /></a></p>
<p>注意，如果Bean不是单例模式，而是采用的原型模式，那么就只会在获取时才创建，并调用init-method，而对应的销毁方法不会被调用（因此，对于原型模式下的Bean，Spring无法顾及其完整生命周期，而在单例模式下，Spring能够从Bean对象的创建一直管理到对象的销毁）官方文档原文如下：</p>
<blockquote>
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp">bean post-processor</a>, which holds a reference to beans that need to be cleaned up.</p>
</blockquote>
<p>Bean之间也是具备继承关系的，只不过这里的继承并不是类的继承，而是属性的继承，比如：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SportStudent</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ArtStudent</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setName</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>此时，我们先将ArtStudent注册一个Bean：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;artStudent&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtStudent&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;name&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;小明&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>这里我们会注入一个name的初始值，此时我们创建了一个SportStudent的Bean，我们希望这个Bean的属性跟刚刚创建的Bean属性是一样的，那么我们可以写一个一模一样的：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.SportStudent&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;name&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;小明&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>但是如果属性太多的话，是不是写起来有点麻烦？这种情况，我们就可以配置Bean之间的继承关系了，我们可以让SportStudent这个Bean直接继承ArtStudent这个Bean配置的属性：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.SportStudent&quot;</span><span class="w"> </span><span class="na">parent=</span><span class="s">&quot;artStudent&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样，在ArtStudent Bean中配置的属性，会直接继承给SportStudent Bean（注意，所有配置的属性，在子Bean中必须也要存在，并且可以进行注入，否则会出现错误）当然，如果子类中某些属性比较特殊，也可以在继承的基础上单独配置：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;artStudent&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtStudent&quot;</span><span class="w"> </span><span class="na">abstract=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;name&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;小明&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;id&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;1&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.SportStudent&quot;</span><span class="w"> </span><span class="na">parent=</span><span class="s">&quot;artStudent&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;id&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;2&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>如果我们只是希望某一个Bean仅作为一个配置模版供其他Bean继承使用，那么我们可以将其配置为abstract，这样，容器就不会创建这个Bean的对象了：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;artStudent&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ArtStudent&quot;</span><span class="w"> </span><span class="na">abstract=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;name&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;小明&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.SportStudent&quot;</span><span class="w"> </span><span class="na">parent=</span><span class="s">&quot;artStudent&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>注意，一旦声明为抽象Bean，那么就无法通过容器获取到其实例化对象了。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/SyDkvOldB7ETW4z.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123140409416" src="https://s2.loli.net/2022/11/23/SyDkvOldB7ETW4z.png" /></a></p>
<p>不过Bean的继承使用频率不是很高，了解就行。</p>
<p>这里最后再提一下，我们前面已经学习了各种各样的Bean配置属性，如果我们希望整个上下文中所有的Bean都采用某种配置，我们可以在最外层的beans标签中进行默认配置：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/KzSUJXa4jBfO9rd.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123141221259" src="https://s2.loli.net/2022/11/23/KzSUJXa4jBfO9rd.png" /></a></p>
<p>这样，即使Bean没有配置某项属性，但是只要在最外层编写了默认配置，那么同样会生效，除非Bean自己进行配置覆盖掉默认配置。</p>
<h3 id="bean_1">工厂模式和工厂Bean<a class="headerlink" href="#bean_1" title="Permanent link">&para;</a></h3>
<p>前面我们介绍了IoC容器的Bean创建机制，默认情况下，容器会调用Bean对应类型的构造方法进行对象创建，但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建，比如在工厂方法设计模式中（详情请观看《Java设计模式》篇 视频教程）我们更希望 Spring不要直接利用反射机制通过构造方法创建Bean对象， 而是利用反射机制先找到对应的工厂类，然后利用工厂类去生成需要的Bean对象：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Student</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我被构造了&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentFactory</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">getStudent</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;欢迎光临电子厂&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>此时Student有一个工厂，我们正常情况下需要使用工厂才可以得到Student对象，现在我们希望Spring也这样做，不要直接去反射搞构造方法创建，我们可以通过factory-method进行指定：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.StudentFactory&quot;</span><span class="w"> </span><span class="na">factory-method=</span><span class="s">&quot;getStudent&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>注意，这里的Bean类型需要填写为Student类的工厂类，并且添加factory-method指定对应的工厂方法，但是最后注册的是工厂方法的返回类型，所以说依然是Student的Bean：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/5Id43xPneJiWfZs.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123143302785" src="https://s2.loli.net/2022/11/23/5Id43xPneJiWfZs.png" /></a></p>
<p>此时我们再去进行获取，拿到的也是通过工厂方法得到的对象：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/l8HzN7Rwthqrim5.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123143347376" src="https://s2.loli.net/2022/11/23/l8HzN7Rwthqrim5.png" /></a></p>
<p>这里有一个误区，千万不要认为是我们注册了StudentFactory这个Bean，class填写为这个类这个只是为了告诉Spring我们的工厂方法在哪个位置，真正注册的是工厂方法提供的东西。</p>
<p>可以发现，当我们采用工厂模式后，我们就无法再通过配置文件对Bean进行依赖注入等操作了，而是只能在工厂方法中完成，这似乎与Spring的设计理念背道而驰？</p>
<p>当然，可能某些工厂类需要构造出对象之后才能使用，我们也可以将某个工厂类直接注册为工厂Bean：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentFactory</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">getStudent</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;欢迎光临电子厂&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>现在需要StudentFactory对象才可以获取到Student，此时我们就只能先将其注册为Bean了：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;studentFactory&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.StudentFactory&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>像这样将工厂类注册为Bean，我们称其为工厂Bean，然后再使用<code>factory-bean</code>来指定Bean的工厂Bean：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">factory-bean=</span><span class="s">&quot;studentFactory&quot;</span><span class="w"> </span><span class="na">factory-method=</span><span class="s">&quot;getStudent&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>注意，使用factory-bean之后，不再要求指定class，我们可以直接使用了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/ih1Af7xBdX3ebaG.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123164134470" src="https://s2.loli.net/2022/11/23/ih1Af7xBdX3ebaG.png" /></a></p>
<p>此时可以看到，工厂方法上同样有了图标，这种方式，由于工厂类被注册为Bean，此时我们就可以在配置文件中为工厂Bean配置依赖注入等内容了。</p>
<p>这里还有一个很细节的操作，如果我们想获取工厂Bean为我们提供的Bean，可以直接输入工厂Bean的名称，这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Student</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;studentFactory&quot;</span><span class="p">);</span>
</code></pre></div>
<p>当然，如果我们需要获取工厂类的实例，可以在名称前面添加<code>&amp;</code>符号：</p>
<div class="highlight"><pre><span></span><code><span class="n">StudentFactory</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">StudentFactory</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;&amp;studentFactory&quot;</span><span class="p">);</span>
</code></pre></div>
<p>又是一个小细节。</p>
<h3 id="_4">使用注解开发<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>前面我们已经完成了大部分的配置文件学习，但是我们发现，使用配置文件进行配置，貌似有点太累了吧？可以想象一下，如果我们的项目非常庞大，整个配置文件将会充满Bean配置，并且会继续庞大下去，能否有一种更加高效的方法能够省去配置呢？还记得我们在JavaWeb阶段用到的非常方便东西吗？没错，就是注解。</p>
<p>既然现在要使用注解来进行开发，那么我们就删掉之前的xml配置文件吧，我们来看看使用注解能有多方便。</p>
<div class="highlight"><pre><span></span><code><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">();</span>
</code></pre></div>
<p>现在我们使用AnnotationConfigApplicationContext作为上下文实现，它是注解配置的。</p>
<p>既然现在采用注解，我们就需要使用类来编写配置文件，在之前，我们如果要编写一个配置的话，需要：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;beans</span><span class="w"> </span><span class="na">xmlns=</span><span class="s">&quot;http://www.springframework.org/schema/beans&quot;</span>
<span class="w">       </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w">       </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.springframework.org/schema/beans</span>
<span class="s">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div>
<p>现在我们只需要创建一个配置类就可以了：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>这两者是等价的，同样的，在一开始会提示我们没有配置上下文：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/YNl5nVkfJriogdD.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123175555433" src="https://s2.loli.net/2022/11/23/YNl5nVkfJriogdD.png" /></a></p>
<p>这里按照要求配置一下就可以，同上，这个只是会影响IDEA的代码提示，不会影响程序运行。</p>
<p>我们可以为AnnotationConfigApplicationContext指定一个默认的配置类：</p>
<div class="highlight"><pre><span></span><code><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="c1">//这个构造方法可以接收多个配置类（更准确的说是多个组件）</span>
</code></pre></div>
<p>那么现在我们该如何配置Bean呢？</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Bean</span><span class="p">(</span><span class="s">&quot;student&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">student</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这样写相对于配置文件中的：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;beans</span><span class="w"> </span><span class="na">xmlns=</span><span class="s">&quot;http://www.springframework.org/schema/beans&quot;</span>
<span class="w">       </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w">       </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.springframework.org/schema/beans</span>
<span class="s">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div>
<p>通过@Import还可以引入其他配置类：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Import</span><span class="p">(</span><span class="n">LBWConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">  </span><span class="c1">//在讲解到Spring原理时，我们还会遇到它，目前只做了解即可。</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>只不过现在变成了由Java代码为我们提供Bean配置，这样会更加的灵活，也更加便于控制Bean对象的创建。</p>
<div class="highlight"><pre><span></span><code><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student</span><span class="p">);</span>
</code></pre></div>
<p>使用方法是相同的，这跟使用XML配置是一样的。</p>
<p>那么肯定就有小伙伴好奇了，我们之前使用的那么多特性在哪里配置呢？首先，初始化方法和摧毁方法、自动装配可以直接在@Bean注解中进行配置：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Bean</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">initMethod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">destroyMethod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">autowireCandidate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">student</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>其次，我们可以使用一些其他的注解来配置其他属性，比如：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Bean</span>
<span class="nd">@Lazy</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">     </span><span class="c1">//对应lazy-init属性</span>
<span class="nd">@Scope</span><span class="p">(</span><span class="s">&quot;prototype&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1">//对应scope属性</span>
<span class="nd">@DependsOn</span><span class="p">(</span><span class="s">&quot;teacher&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1">//对应depends-on属性</span>
<span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">student</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>对于那些我们需要通过构造方法或是Setter完成依赖注入的Bean，比如：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.ProgramTeacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;com.test.bean.Student&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;teacher&quot;</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;teacher&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>像这种需要引入其他Bean进行的注入，我们可以直接将其作为形式参数放到方法中：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Bean</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="nf">teacher</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Teacher</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Bean</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">student</span><span class="p">(</span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">(</span><span class="n">teacher</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>此时我们可以看到，旁边已经出现图标了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/wy5JtiVp8zK1bmG.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123213527325" src="https://s2.loli.net/2022/11/23/wy5JtiVp8zK1bmG.png" /></a></p>
<p>运行程序之后，我们发现，这样确实可以直接得到对应的Bean并使用。</p>
<p>只不过，除了这种基于构造器或是Setter的依赖注入之外，我们也可以直接到Bean对应的类中使用自动装配：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Autowired</span><span class="w">   </span><span class="c1">//使用此注解来进行自动装配，由IoC容器自动为其赋值</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>现在，我们甚至连构造方法和Setter都不需要去编写了，就能直接完成自动装配，是不是感觉比那堆配置方便多了？</p>
<p>当然，@Autowired并不是只能用于字段，对于构造方法或是Setter，它同样可以：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Autowired</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setTeacher</span><span class="p">(</span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>@Autowired默认采用byType的方式进行自动装配，也就是说会使用类型进行配，那么要是出现了多个相同类型的Bean，如果我们想要指定使用其中的某一个该怎么办呢？</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Bean</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="nf">teacherA</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Teacher</span><span class="p">();</span>
<span class="p">}</span>

<span class="nd">@Bean</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="nf">teacherB</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Teacher</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>此时，我们可以配合@Qualifier进行名称匹配：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Autowired</span>
<span class="w">    </span><span class="nd">@Qualifier</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">//匹配名称为a的Teacher类型的Bean</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这里需要提一下，在我们旧版本的SSM教程中讲解了@Resource这个注解，但是现在它没有了。</p>
<p>随着Java版本的更新迭代，某些javax包下的包，会被逐渐弃用并移除。在JDK11版本以后，javax.annotation这个包被移除并且更名为jakarta.annotation（我们在JavaWeb篇已经介绍过为什么要改名字了）其中有一个非常重要的注解，叫做@Resource，它的作用与@Autowired时相同的，也可以实现自动装配，但是在IDEA中并不推荐使用@Autowired注解对成员字段进行自动装配，而是推荐使用@Resource，如果需要使用这个注解，还需要额外导入包：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>jakarta.annotation<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>jakarta.annotation-api<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>2.1.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p>使用方法一样，直接替换掉就可以了：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Resource</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>只不过，他们两有些机制上的不同：</p>
<ul>
<li>@Resource默认<strong>ByName</strong>如果找不到则<strong>ByType</strong>，可以添加到set方法、字段上。</li>
<li>@Autowired默认是<strong>byType</strong>，只会根据类型寻找，可以添加在构造方法、set方法、字段、方法参数上。</li>
</ul>
<p>因为@Resource的匹配机制更加合理高效，因此官方并不推荐使用@Autowired字段注入，当然，实际上Spring官方更推荐我们使用基于构造方法或是Setter的@Autowired注入，比如Setter 注入的一个好处是，Setter 方法使该类的对象能够在以后重新配置或重新注入。其实，最后使用哪个注解，还是看你自己，要是有强迫症不能忍受黄标但是又实在想用字段注入，那就用@Resource注解。</p>
<p>除了这个注解之外，还有@PostConstruct和@PreDestroy，它们效果和init-method和destroy-method是一样的：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@PostConstruct</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是初始化方法&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">@PreDestroy</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是销毁方法&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>我们只需要将其添加到对应的方法上即可：</p>
<div class="highlight"><pre><span></span><code><span class="n">AnnotationConfigApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">context</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/23/wXRuAjVF2ykCOJ4.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221123225232979" src="https://s2.loli.net/2022/11/23/wXRuAjVF2ykCOJ4.png" /></a></p>
<p>可以看到效果是完全一样的，这些注解都是jakarta.annotation提供的，有关Spring和JakartaEE的渊源，还请各位小伙伴自行了解。</p>
<p>前面我们介绍了使用@Bean来注册Bean，但是实际上我们发现，如果只是简单将一个类作为Bean的话，这样写还是不太方便，因为都是固定模式，就是单纯的new一个对象出来，能不能像之前一样，让容器自己反射获取构造方法去生成这个对象呢？</p>
<p>肯定是可以的，我们可以在需要注册为Bean的类上添加<code>@Component</code>注解来将一个类进行注册<strong>（现在最常用的方式）</strong>，不过要实现这样的方式，我们需要添加一个自动扫描来告诉Spring，它需要在哪些包中查找我们提供的<code>@Component</code>声明的Bean。</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span><span class="p">(</span><span class="s">&quot;lbwnb&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">//同样可以自己起名字</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>
</code></pre></div>
<p>要注册这个类的Bean，只需要添加@Component即可，然后配置一下包扫描：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;com.test.bean&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">//包扫描，这样Spring就会去扫描对应包下所有的类</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>
</code></pre></div>
<p>Spring在扫描对应包下所有的类时，会自动将那些添加了@Component的类注册为Bean，是不是感觉很方便？只不过这种方式只适用于我们自己编写类的情况，如果是第三方包提供的类，只能使用前者完成注册，并且这种方式并不是那么的灵活。</p>
<p>不过，无论是通过@Bean还是@Component形式注册的Bean，Spring都会为其添加一个默认的name属性，比如：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>它的默认名称生产规则依然是类名并按照首字母小写的驼峰命名法来的，所以说对应的就是student：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Student</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;student&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//这样同样可以获取到</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student</span><span class="p">);</span>
</code></pre></div>
<p>同样的，如果是通过@Bean注册的，默认名称是对应的方法名称：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Bean</span>
<span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">artStudent</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Student</span><span class="p">)</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;artStudent&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student</span><span class="p">);</span>
</code></pre></div>
<p>相比传统的XML配置方式，注解形式的配置确实能够减少我们很多工作量。并且，对于这种使用<code>@Component</code>注册的Bean，如果其构造方法不是默认无参构造，那么默认会对其每一个参数都进行自动注入：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">){</span><span class="w">   </span><span class="c1">//如果有Teacher类型的Bean，那么这里的参数会被自动注入</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">teacher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>最后，对于我们之前使用的工厂模式，Spring也提供了接口，我们可以直接实现接口表示这个Bean是一个工厂Bean：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentFactory</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">FactoryBean</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">getObject</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//生产的Bean对象</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="nf">getObjectType</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//生产的Bean类型</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isSingleton</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//生产的Bean是否采用单例模式</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上跟我们之前在配置文件中编写是一样的，这里就不多说了。</p>
<p>请注意，使用注解虽然可以省事很多，代码也能变得更简洁，但是这并不代表XML配置文件就是没有意义的，它们有着各自的优点，在不同的场景下合理使用，能够起到事半功倍的效果，官方原文：</p>
<blockquote>
<p>Are annotations better than XML for configuring Spring?</p>
<p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.</p>
<p>No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">JavaConfig</a> option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the <a href="https://spring.io/tools">Spring Tools for Eclipse</a>.</p>
</blockquote>
<p>至此，关于Spring的IoC基础部分，我们就全部介绍完了。在最后，留给各位小伙伴一个问题，现在有两个类：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Resource</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Teacher</span><span class="w"> </span><span class="n">teacher</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Teacher</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Resource</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这两个类互相需要注入对方的实例对象，这个时候Spring会怎么进行处理呢？如果Bean变成原型模式，Spring又会怎么处理呢？</p>
<p>这个问题我们会在实现原理探究部分进行详细介绍。</p>
<hr />
<h2 id="spring_2">Spring高级特性（选学）<a class="headerlink" href="#spring_2" title="Permanent link">&para;</a></h2>
<p><strong>注意：</strong>本部分为选学内容，如果Spring基础部分学的不是很明白，不建议看这一部分，在理解清楚之后再来看也可以，但也不是说以后就不用学了，这些东西在某些项目中可能会用到，你迟早还是要回来补的。</p>
<p>前面我们介绍了Spring的基础部分，我们接着来介绍Spring的一些其他高级特性。</p>
<h3 id="bean-aware">Bean Aware<a class="headerlink" href="#bean-aware" title="Permanent link">&para;</a></h3>
<p>在Spring中提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化之后，可以获取相应资源。Aware的中文意思为<strong>感知</strong>。简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring容器会在Bean被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法。</p>
<p>比如BeanNameAware之类的以Aware结尾的接口，这个接口获取的资源就是BeanName：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanNameAware</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//我们只需要实现这个接口就可以了</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setBeanName</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//Bean在加载的时候，容器就会自动调用此方法，将Bean的名称给到我们</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我在加载阶段获得了Bean名字：&quot;</span><span class="o">+</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>又比如BeanClassLoaderAware，那么它能够使得我们可以在Bean加载阶段就获取到当前Bean的类加载器：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanClassLoaderAware</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setBeanClassLoader</span><span class="p">(</span><span class="n">ClassLoader</span><span class="w"> </span><span class="n">classLoader</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">classLoader</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>有关其他的Aware这里就不一一列举了，我们会在后面的实现原理探究部分逐步认识的。</p>
<h3 id="_5">任务调度<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>为了执行某些任务，我们可能需要一些非常规的操作，比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。这时我们首先想到的就是创建一个新的线程来处理，或是使用TimerTask来完成定时任务，但是我们有了Spring框架之后，就不用这样了，因为Spring框架为我们提供了更加便捷的方式进行任务调度。</p>
<p>首先我们来看异步任务执行，需要使用Spring异步任务支持，我们需要在配置类上添加<code>@EnableAsync</code>注解。</p>
<div class="highlight"><pre><span></span><code><span class="nd">@EnableAsync</span>
<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;com.test.bean&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>接着我们只需要在需要异步执行的方法上，添加<code>@Async</code>注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，而不是在当前线程执行。我们来测试一下：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">syncTest</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="o">+</span><span class="s">&quot;我是同步执行的方法，开始...&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是同步执行的方法，结束！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Async</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">asyncTest</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="o">+</span><span class="s">&quot;我是异步执行的方法，开始...&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是异步执行的方法，结束！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>现在我们在主方法中分别调用一下试试看：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">AnnotationConfigApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">student</span><span class="p">.</span><span class="na">asyncTest</span><span class="p">();</span><span class="w">   </span><span class="c1">//异步执行</span>
<span class="w">    </span><span class="n">student</span><span class="p">.</span><span class="na">syncTest</span><span class="p">();</span><span class="w">    </span><span class="c1">//同步执行</span>
<span class="p">}</span>
</code></pre></div>
<p>可以看到，我们的任务执行结果为：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/7VKh3dreROJUTcN.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125153110860" src="https://s2.loli.net/2022/11/25/7VKh3dreROJUTcN.png" /></a></p>
<p>很明显，异步执行的任务并不是在当前线程启动的，而是在其他线程启动的，所以说并不会在当前线程阻塞，可以看到马上就开始执行下一行代码，调用同步执行的任务了。</p>
<p>因此，当我们要将Bean的某个方法设计为异步执行时，就可以直接添加这个注解。但是需要注意，添加此注解要求方法的返回值只能是void或是Future类型才可以（Future类型我们在JUC篇视频教程中有详细介绍）</p>
<p>还有，在使用时，可能还会出现这样的信息：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/7RfCIvYAZhMDPJe.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125153426124" src="https://s2.loli.net/2022/11/25/7RfCIvYAZhMDPJe.png" /></a></p>
<p>虽然出现了这样的信息，但是我们的程序依然可以正常运行，这是因为Spring默认会从容器中选择一个<code>Executor</code>类型（这同样是在JUC篇视频教程中介绍的类型）的实例，并使用它来创建线程执行任务，这是Spring推荐的方式，当然，如果没有找到，那么会使用自带的 SimpleAsyncTaskExecutor 处理异步方法调用。</p>
<p>肯定会有小伙伴疑惑，什么情况？！这个方法很明显我们并没有去编写异步执行的逻辑，那么为什么会异步执行呢？这里很明显是同步调用的方法啊。的确，如果这个Bean只是一个简简单单的Student类型的对象，确实做不到。但是它真的只是一个简简单单的Student类型对象吗？</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="na">getClass</span><span class="p">());</span><span class="w">   </span><span class="c1">//这里我们通过getClass来获取一下类型，你会发现惊喜</span>
</code></pre></div>
<p>我们来看看结果：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/qUlV5hj96YEupQM.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125154133618" src="https://s2.loli.net/2022/11/25/qUlV5hj96YEupQM.png" /></a></p>
<p>？？？这是什么东西？这实际上Spring帮助我们动态生成的一个代理类，我们原本的类代码已经被修改了，当然，这只是冰山一角，更多的内容，我们还会再AOP面向切片部分中继续为大家进行介绍，能做到这样的操作，这其实都是AOP的功劳。</p>
<p>看完了异步任务，我们接着来看定时任务，定时任务其实就是指定在哪个时候再去执行，在JavaSE阶段我们使用过TimerTask来执行定时任务。Spring中的定时任务是全局性质的，当我们的Spring程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加<code>@EnableScheduling</code>注解：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@EnableScheduling</span>
<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;com.test.bean&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>接着我们可以直接在配置类里面编写定时任务，把我们要做的任务写成方法，并添加<code>@Scheduled</code>注解：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Scheduled</span><span class="p">(</span><span class="n">fixedRate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span><span class="p">)</span><span class="w">   </span><span class="c1">//单位依然是毫秒，这里是每两秒钟打印一次</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">task</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是定时任务！&quot;</span><span class="o">+</span><span class="k">new</span><span class="w"> </span><span class="n">Date</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/aGv7f3eBXPsFdYr.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125155352390" src="https://s2.loli.net/2022/11/25/aGv7f3eBXPsFdYr.png" /></a></p>
<p>我们注意到<code>@Scheduled</code>中有很多参数，我们需要指定'cron', 'fixedDelay(String)', or 'fixedRate(String)'的其中一个，否则无法创建定时任务，他们的区别如下：</p>
<ul>
<li>fixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。</li>
<li>fixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。</li>
<li>cron：如果嫌上面两个不够灵活，你还可以使用cron表达式来指定任务计划。</li>
</ul>
<p>这里简单讲解一下cron表达式：<a href="https://blog.csdn.net/sunnyzyq/article/details/98597252">https://blog.csdn.net/sunnyzyq/article/details/98597252</a></p>
<h3 id="_6">监听器<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>监听器对我们来说也是一个比较陌生的概念，那么何谓监听呢？</p>
<p>监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知，如果你学习过Java Swing篇视频教程，应该会深有体会，监听器可是很关键的，只不过在Spring中用的不是很频繁罢了。但是这里还是要简单介绍一下：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestListener</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ApplicationListener</span><span class="o">&lt;</span><span class="n">ContextRefreshedEvent</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onApplicationEvent</span><span class="p">(</span><span class="n">ContextRefreshedEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="na">getApplicationContext</span><span class="p">());</span><span class="w">   </span><span class="c1">//可以直接通过事件获取到事件相关的东西</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>要编写监听器，我们只需要让Bean继承ApplicationListener就可以了，并且将类型指定为对应的Event事件，这样，当发生某个事件时就会通知我们，比如ContextRefreshedEvent，这个事件会在Spring容器初始化完成会触发一次：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/MZN3eohGmV17vUJ.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125155804255" src="https://s2.loli.net/2022/11/25/MZN3eohGmV17vUJ.png" /></a></p>
<p>是不是感觉挺智能的？Spring内部有各种各样的事件，当然我们也可以自己编写事件，然后在某个时刻发布这个事件到所有的监听器：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestEvent</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">ApplicationEvent</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//自定义事件需要继承ApplicationEvent</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">TestEvent</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">super</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestListener</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ApplicationListener</span><span class="o">&lt;</span><span class="n">TestEvent</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onApplicationEvent</span><span class="p">(</span><span class="n">TestEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;发生了一次自定义事件，成功监听到！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>比如现在我们希望在定时任务中每秒钟发生一次这个事件：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TaskComponent</span><span class="w">  </span><span class="kd">implements</span><span class="w"> </span><span class="n">ApplicationEventPublisherAware</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="c1">//要发布事件，需要拿到ApplicationEventPublisher，这里我们通过Aware在初始化的时候拿到</span>
<span class="w">    </span><span class="c1">//实际上我们的ApplicationContext就是ApplicationEventPublisher的实现类，这里拿到的就是</span>
<span class="w">    </span><span class="c1">//我们创建的ApplicationContext对象</span>
<span class="w">    </span><span class="n">ApplicationEventPublisher</span><span class="w"> </span><span class="n">publisher</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Scheduled</span><span class="p">(</span><span class="n">fixedRate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w">   </span><span class="c1">//一秒一次</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">task</span><span class="p">(){</span>
<span class="w">        </span><span class="c1">//直接通过ApplicationEventPublisher的publishEvent方法发布事件</span>
<span class="w">        </span><span class="c1">//这样，所有这个事件的监听器，都会监听到这个事件发生了</span>
<span class="w">        </span><span class="n">publisher</span><span class="p">.</span><span class="na">publishEvent</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">TestEvent</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setApplicationEventPublisher</span><span class="p">(</span><span class="n">ApplicationEventPublisher</span><span class="w"> </span><span class="n">publisher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">publisher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">publisher</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>此时，发布事件旁边出现了图标，说明就可以了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/fDxYEGPWdyMt7XF.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125161224037" src="https://s2.loli.net/2022/11/25/fDxYEGPWdyMt7XF.png" /></a></p>
<p>我们可以点击这个图标快速跳转到哪里监听了这个事件，IDEA这些细节做的还是挺好的。我们来看看运行结果吧：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/FKy1jBx3MJvVdDN.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125161125557" src="https://s2.loli.net/2022/11/25/FKy1jBx3MJvVdDN.png" /></a></p>
<p>是不是感觉好像也没那么难，这套机制其实还挺简单的，这样，我们就实现了自定义事件发布和监听。</p>
<hr />
<h2 id="springel">SpringEL表达式<a class="headerlink" href="#springel" title="Permanent link">&para;</a></h2>
<p>SpEL 是一种强大，简洁的装配 Bean 的方式，它可以通过运行期间执行的表达式将值装配到我们的属性或构造函数当中，更可以调用 JDK 中提供的静态常量，获取外部 Properties 文件中的的配置。</p>
<h3 id="_7">外部属性注入<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>有些时候，我们甚至可以将一些外部配置文件中的配置进行读取，并完成注入。</p>
<p>我们需要创建以<code>.properties</code>结尾的配置文件，这种配置文件格式很简单，类似于Map，需要一个Key和一个Value，中间使用等号进行连接，这里我们在resource目录下创建一个<code>test.properties</code>文件：</p>
<div class="highlight"><pre><span></span><code><span class="na">test.name</span><span class="o">=</span><span class="s">只因</span>
</code></pre></div>
<p>这样，Key就是<code>test.name</code>，Value就是<code>只因</code>，我们可以通过一个注解直接读取到外部配置文件中对应的属性值，首先我们需要引入这个配置文件，我们可以在配置类上添加<code>@PropertySource</code>注解：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;com.test.bean&quot;</span><span class="p">)</span>
<span class="nd">@PropertySource</span><span class="p">(</span><span class="s">&quot;classpath:test.properties&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">//注意，类路径下的文件名称需要在前面加上classpath:</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="p">{</span>

<span class="p">}</span>
</code></pre></div>
<p>接着，我们就可以开始快乐的使用了，我们可以使用 @Value 注解将外部配置文件中的值注入到任何我们想要的位置，就像我们之前使用@Resource自动注入一样：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Value</span><span class="p">(</span><span class="s">&quot;${test.name}&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">//这里需要在外层套上 ${ }</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w">   </span><span class="c1">//String会被自动赋值为配置文件中对应属性的值</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的名字是：&quot;</span><span class="o">+</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>@Value</code>中的<code>${...}</code>表示占位符，它会读取外部配置文件的属性值装配到属性中，如果配置正确没问题的话，这里甚至还会直接显示对应配置项的值：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/HDZ4l3tcreoOGh8.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125164854022" src="https://s2.loli.net/2022/11/25/HDZ4l3tcreoOGh8.png" /></a></p>
<p>我们来测试一下吧：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/g5tBKW4Sm9lXnrR.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125165145332" src="https://s2.loli.net/2022/11/25/g5tBKW4Sm9lXnrR.png" /></a></p>
<p>如果遇到乱码的情况，请将配置文件的编码格式切换成UTF-8（可以在IDEA设置中进行配置）然后在@PropertySource注解中添加属性 encoding = "UTF-8" 这样就正常了，当然，其实一般情况下也很少会在配置文件中用到中文。</p>
<p>除了在字段上进行注入之外，我们也可以在需要注入的方法中使用：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//构造方法中的参数除了被自动注入外，我们也可以选择使用@Value进行注入</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="nd">@Value</span><span class="p">(</span><span class="s">&quot;${test.name}&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的名字是：&quot;</span><span class="o">+</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>当然，如果我们只是想简单的注入一个常量值，也可以直接填入固定值：</p>
<div class="highlight"><pre><span></span><code><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="nd">@Value</span><span class="p">(</span><span class="s">&quot;10&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">){</span><span class="w">   </span><span class="c1">//只不过，这里都是常量值了，我干嘛不直接写到代码里呢</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>当然，@Value 的功能还远不止这些，配合SpringEL表达式，能够实现更加强大的功能。</p>
<h3 id="spel">SpEL简单使用<a class="headerlink" href="#spel" title="Permanent link">&para;</a></h3>
<p>Spring官方为我们提供了一套非常高级SpEL表达式，通过使用表达式，我们可以更加灵活地使用Spring框架。</p>
<p>首先我们来看看如何创建一个SpEL表达式：</p>
<div class="highlight"><pre><span></span><code><span class="n">ExpressionParser</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SpelExpressionParser</span><span class="p">();</span>
<span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;&#39;Hello World&#39;&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">//使用parseExpression方法来创建一个表达式</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span><span class="w">   </span><span class="c1">//表达式最终的运算结果可以通过getValue()获取</span>
</code></pre></div>
<p>这里得到的就是一个很简单的 Hello World 字符串，字符串使用单引号囊括，SpEL是具有运算能力的。</p>
<p>我们可以像写Java一样，对这个字符串进行各种操作，比如调用方法之类的：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;&#39;Hello World&#39;.toUpperCase()&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//调用String的toUpperCase方法</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/PZmheYn5EVTvURN.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125173157008" src="https://s2.loli.net/2022/11/25/PZmheYn5EVTvURN.png" /></a></p>
<p>不仅能调用方法、还可以访问属性、使用构造方法等，是不是感觉挺牛的，居然还能这样玩。</p>
<p>对于Getter方法，我们可以像访问属性一样去使用：</p>
<div class="highlight"><pre><span></span><code><span class="c1">//比如 String.getBytes() 方法，就是一个Getter，那么可以写成 bytes</span>
<span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;&#39;Hello World&#39;.bytes&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<p>表达式可以不止一级，我们可以多级调用：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;&#39;Hello World&#39;.bytes.length&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//继续访问数组的length属性</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<p>是不是感觉挺好玩的？我们继续来试试看构造方法，其实就是写Java代码，只是可以写成这种表达式而已：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;new String(&#39;hello world&#39;).toUpperCase()&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/25/PZmheYn5EVTvURN.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221125173157008" src="https://s2.loli.net/2022/11/25/PZmheYn5EVTvURN.png" /></a></p>
<p>它甚至还支持根据特定表达式，从给定对象中获取属性出来：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Student</span><span class="p">(</span><span class="nd">@Value</span><span class="p">(</span><span class="s">&quot;${test.name}&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">getName</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="c1">//比如下面要访问name属性，那么这个属性得可以访问才行，访问权限不够是不行的</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">ExpressionParser</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SpelExpressionParser</span><span class="p">();</span>
<span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span><span class="w">    </span><span class="c1">//直接读取对象的name属性</span>
</code></pre></div>
<p>拿到对象属性之后，甚至还可以继续去处理：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;name.bytes.length&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//拿到name之后继续getBytes然后length</span>
</code></pre></div>
<p>除了获取，我们也可以调用表达式的setValue方法来设定属性的值：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">);</span>
<span class="n">exp</span><span class="p">.</span><span class="na">setValue</span><span class="p">(</span><span class="n">student</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;刻师傅&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//同样的，这个属性得有访问权限且能set才可以，否则会报错</span>
</code></pre></div>
<p>除了属性调用，我们也可以使用运算符进行各种高级运算：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;66 &gt; 77&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//比较运算</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;99 + 99 * 3&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//算数运算</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<p>对于那些需要导入才能使用的类，我们需要使用一个特殊的语法：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;T(java.lang.Math).random()&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//由T()囊括，包含完整包名+类名</span>
<span class="c1">//Expression exp = parser.parseExpression(&quot;T(System).nanoTime()&quot;);   //默认导入的类可以不加包名</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<h3 id="_8">集合操作相关语法<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>现在我们的类中存在一些集合类：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;你干嘛&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&quot;AAA&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;BBB&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CCC&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>我们可以使用SpEL快速取出集合中的元素：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;map[&#39;test&#39;]&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">//对于Map这里映射型，可以直接使用map[key]来取出value</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;list[2]&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//对于List、数组这类，可以直接使用[index]</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<p>我们也可以快速创建集合：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;{5, 2, 1, 4, 6, 7, 0, 3, 9, 8}&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">//使用{}来快速创建List集合</span>
<span class="n">List</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">List</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
<span class="n">value</span><span class="p">.</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">::</span><span class="n">println</span><span class="p">);</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;{{1, 2}, {3, 4}}&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//它是支持嵌套使用的</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//创建Map也很简单，只需要key:value就可以了，怎么有股JSON味</span>
<span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;{name: &#39;小明&#39;, info: {address: &#39;北京市朝阳区&#39;, tel: 10086}}&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">());</span>
</code></pre></div>
<p>你以为就这么简单吗，我们还可以直接根据条件获取集合中的元素：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Clazz</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Clazz</span><span class="p">(</span><span class="s">&quot;高等数学&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">record</span> <span class="nc">Clazz</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">score</span><span class="p">){</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//现在我们希望从list中获取那些满足我们条件的元素，并组成一个新的集合，我们可以使用.?运算符</span>
<span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;list.?[name == &#39;高等数学&#39;]&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;list.?[score &gt; 3]&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//选择学分大于3分的科目</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<p>我们还可以针对某个属性创建对应的投影集合：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;list.![name]&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//使用.!创建投影集合，这里创建的时课程名称组成的新集合</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/30/yLNHPJnWkoR3Cb2.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221130153142677" src="https://s2.loli.net/2022/11/30/yLNHPJnWkoR3Cb2.png" /></a></p>
<p>我们接着来介绍安全导航运算符，安全导航运算符用于避免NullPointerException，它来自Groovy语言。通常，当您有对对象的引用时，您可能需要在访问对象的方法或属性之前验证它是否为空。为了避免这种情况，安全导航运算符返回null而不是抛出异常。以下示例显示了如何使用安全导航运算符：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;name.toUpperCase()&quot;</span><span class="p">);</span><span class="w">   </span><span class="c1">//如果Student对象中的name属性为null</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/30/dojeP5kYcM7KHiv.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221130150723018" src="https://s2.loli.net/2022/11/30/dojeP5kYcM7KHiv.png" /></a></p>
<p>当遇到null时很不方便，我们还得写判断：</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="na">name</span><span class="p">.</span><span class="na">toUpperCase</span><span class="p">());</span>
</code></pre></div>
<p>Java 8之后能这样写：</p>
<div class="highlight"><pre><span></span><code><span class="n">Optional</span><span class="p">.</span><span class="na">ofNullable</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="na">name</span><span class="p">).</span><span class="na">ifPresent</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">::</span><span class="n">println</span><span class="p">);</span>
</code></pre></div>
<p>但是你如果写过Kotlin：
<div class="highlight"><pre><span></span><code><span class="n">println</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="na">name</span><span class="o">?.</span><span class="na">toUpperCase</span><span class="p">());</span>
</code></pre></div></p>
<p>类似于这种判空问题，我们就可以直接使用安全导航运算符，SpEL也支持这种写法：</p>
<div class="highlight"><pre><span></span><code><span class="n">Expression</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parseExpression</span><span class="p">(</span><span class="s">&quot;name?.toUpperCase()&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">exp</span><span class="p">.</span><span class="na">getValue</span><span class="p">(</span><span class="n">student</span><span class="p">));</span>
</code></pre></div>
<p>当遇到空时，只会得到一个null，而不是直接抛出一个异常：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/30/tOf3LFsWE4H8BVc.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221130150654287" src="https://s2.loli.net/2022/11/30/tOf3LFsWE4H8BVc.png" /></a></p>
<p>我们可以将SpEL配合 @Value 注解或是xml配置文件中的value属性使用，比如XML中可以这样写：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;numberGuess&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;org.spring.samples.NumberGuess&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;randomNumber&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;#{ T(java.lang.Math).random() * 100.0 }&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>
<p>或是使用注解开发：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">FieldValueTestBean</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Value</span><span class="p">(</span><span class="s">&quot;#{ systemProperties[&#39;user.region&#39;] }&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">defaultLocale</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这样，我们有时候在使用配置文件中的值时，就能进行一些简单的处理了。</p>
<p>有关更多详细语法教程，请前往：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-language-ref">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-language-ref</a></p>
<hr />
<h2 id="aop">AOP面向切片<a class="headerlink" href="#aop" title="Permanent link">&para;</a></h2>
<p>又是一个听起来很高大上的名词，AOP（Aspect Oriented Programming）思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上。也就是说，我们可以使用AOP来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，它就是代理！</p>
<p>通过AOP我们可以在保证原有业务不变的情况下，添加额外的动作，比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用AOP来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/11/30/sJbSrgiAxa8Vhcv.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221130155358974" src="https://s2.loli.net/2022/11/30/sJbSrgiAxa8Vhcv.png" /></a></p>
<p>相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。它的原理实际上就是通过动态代理机制实现的，我们在JavaWeb阶段已经给大家讲解过动态代理了。不过Spring底层并不是使用的JDK提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不仅仅是接口。</p>
<h3 id="aop_1">使用配置实现AOP<a class="headerlink" href="#aop_1" title="Permanent link">&para;</a></h3>
<p>在开始之前，我们先换回之前的XML配置模式，之后也会给大家讲解如何使用注解完成AOP操作，注意这里我们还加入了一些新的AOP相关的约束进来，建议直接CV下面的：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;beans</span><span class="w"> </span><span class="na">xmlns=</span><span class="s">&quot;http://www.springframework.org/schema/beans&quot;</span>
<span class="w">       </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w">       </span><span class="na">xmlns:aop=</span><span class="s">&quot;http://www.springframework.org/schema/aop&quot;</span>
<span class="w">       </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span>
<span class="s">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div>
<p>Spring是支持AOP编程的框架之一（实际上它整合了AspectJ框架的一部分），要使用AOP我们需要先导入一个依赖：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>spring-aspects<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>6.0.10<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p>那么，如何使用AOP呢？首先我们要明确，要实现AOP操作，我们需要知道这些内容：</p>
<ol>
<li>需要切入的类，类的哪个方法需要被切入</li>
<li>切入之后需要执行什么动作</li>
<li>是在方法执行前切入还是在方法执行后切入</li>
<li>如何告诉Spring需要进行切入</li>
</ol>
<p>比如现在我们希望对这个学生对象的<code>study</code>方法进行增强，在不修改源代码的情况下，增加一些额外的操作：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">study</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;室友还在打游戏，我狠狠的学Java，太爽了&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="c1">//现在我们希望在这个方法执行完之后，打印一些其他的内容，在不修改原有代码的情况下，该怎么做呢？</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="n">bean</span><span class="w"> </span><span class="kd">class</span><span class="err">=&quot;</span><span class="nc">org</span><span class="p">.</span><span class="na">example</span><span class="p">.</span><span class="na">entity</span><span class="p">.</span><span class="na">Student</span><span class="s">&quot;/&gt;</span>
</code></pre></div>
<p>那么我们按照上面的流程，依次来看，首先需要解决的问题是，找到需要切入的类，很明显，就是这个Student类，我们要切入的是这个<code>study</code>方法。</p>
<p>第二步，我们切入之后要做什么呢？这里我们直接创建一个新的类，并将要执行的操作写成一个方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentAOP</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//这个方法就是我们打算对其进行的增强操作</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterStudy</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;为什么毕业了他们都继承家产，我还倒给他们打工，我努力的意义在哪里...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>注意这个类也得注册为Bean才可以：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;studentAOP&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;org.example.entity.StudentAOP&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>第三步，我们要明确这是在方法执行之前切入还是执行之后切入，很明显，按照上面的要求，我们需要执行之后进行切入。</p>
<p>第四步，最关键的来了，我们怎么才能告诉Spring我们要进行切入操作呢？这里我们需要在配置文件中进行AOP配置：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:config&gt;</span>

<span class="nt">&lt;/aop:config&gt;</span>
</code></pre></div>
<p>接着我们需要添加一个新的切点，首先填写ID，这个随便起都可以：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:pointcut</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="na">expression=</span><span class="s">&quot;&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>然后就是通过后面的<code>expression</code>表达式来选择到我们需要切入的方法，这个表达式支持很多种方式进行选择，Spring AOP支持以下AspectJ切点指示器（PCD）用于表达式：</p>
<ul>
<li><code>execution</code>：用于匹配方法执行连接点。这是使用Spring AOP时使用的主要点切割指示器。</li>
<li><code>within</code>：限制匹配到某些类型的连接点（使用Spring AOP时在匹配类型中声明的方法的执行）。</li>
<li><code>this</code>：限制与连接点匹配（使用Spring AOP时方法的执行），其中bean引用（Spring AOP代理）是给定类型的实例。</li>
<li><code>target</code>：限制匹配连接点（使用Spring AOP时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。</li>
<li><code>args</code>：限制与连接点匹配（使用Spring AOP时方法的执行），其中参数是给定类型的实例。</li>
<li><code>@target</code>：限制匹配连接点（使用Spring AOP时方法的执行），其中执行对象的类具有给定类型的注释。</li>
<li><code>@args</code>：限制匹配到连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。</li>
<li><code>@within</code>：限制与具有给定注释的类型中的连接点匹配（使用Spring AOP时在带有给定注释的类型中声明的方法的执行）。</li>
<li><code>@annotation</code>：与连接点主体（在Spring AOP中运行的方法）具有给定注释的连接点匹配的限制。</li>
</ul>
<p>更多详细内容请查阅：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators</a></p>
<p>其中，我们主要学习的<code>execution</code>填写格式如下：</p>
<div class="highlight"><pre><span></span><code>修饰符<span class="w"> </span>包名.类名.方法名称(方法参数)
</code></pre></div>
<ul>
<li>修饰符：public、protected、private、包括返回值类型、static等等（使用* 代表任意修饰符）</li>
<li>包名：如com.test（<em> 代表全部，比如com.</em> 代表com包下的全部包）</li>
<li>类名：使用* 也可以代表包下的所有类</li>
<li>方法名称：可以使用* 代表全部方法</li>
<li>方法参数：填写对应的参数即可，比如(String, String)，也可以使用* 来代表任意一个参数，使用..代表所有参数。</li>
</ul>
<p>也可以使用其他属性来进行匹配，比如<code>@annotation</code>可以用于表示标记了哪些注解的方法被切入，这里我们就只是简单的执行，所以说只需要这样写就可以了：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:pointcut</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="na">expression=</span><span class="s">&quot;execution(* org.example.entity.Student.study())&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>这样，我们就指明了需要切入的方法，然后就是将我们的增强方法，我们在里面继续添加<code>aop:aspect</code>标签，并使用<code>ref</code>属性将其指向我们刚刚注册的AOP类Bean：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:config&gt;</span>
<span class="w">    </span><span class="nt">&lt;aop:pointcut</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="na">expression=</span><span class="s">&quot;execution(* org.example.entity.Student.study())&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;aop:aspect</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;studentAOP&quot;</span><span class="nt">&gt;</span>

<span class="w">    </span><span class="nt">&lt;/aop:aspect&gt;</span>
<span class="nt">&lt;/aop:config&gt;</span>
</code></pre></div>
<p>接着就是添加后续动作了，当然，官方支持的有多种多样的，比如执行前、执行后、抛出异常后、方法返回后等等：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/uopJ9KyqMvQSwi4.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216155201849" src="https://s2.loli.net/2022/12/16/uopJ9KyqMvQSwi4.png" /></a></p>
<p>其中around方法为环绕方法，自定义度会更高，我们会在稍后介绍。这里我们按照上面的要求，直接添加后续动作，注意需要指明生效的切点：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:aspect</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;studentAOP&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="cm">&lt;!--     method就是我们的增强方法，pointcut-ref指向我们刚刚创建的切点     --&gt;</span>
<span class="w">    </span><span class="nt">&lt;aop:after</span><span class="w"> </span><span class="na">method=</span><span class="s">&quot;afterStudy&quot;</span><span class="w"> </span><span class="na">pointcut-ref=</span><span class="s">&quot;test&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/aop:aspect&gt;</span>
</code></pre></div>
<p>这样，我们就成功配置好了，配置正确会在旁边出现图标：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/hBaSmuovMzp5iIn.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216155551779" src="https://s2.loli.net/2022/12/16/hBaSmuovMzp5iIn.png" /></a></p>
<p>我们来试试看吧：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;application.xml&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">bean</span><span class="p">.</span><span class="na">study</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>结果如下：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/JlvLe9rgQw2pbXo.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216155616952" src="https://s2.loli.net/2022/12/16/JlvLe9rgQw2pbXo.png" /></a></p>
<p>可以看到在我们原本的方法执行完成之后，它还继续执行了我们的增强方法，这实际上就是动态代理做到的，实现在不修改原有代码的基础上，对方法的调用进行各种增强，在之后的SpringMVC学习中，我们甚至可以使用它来快速配置访问日志打印。</p>
<p>前面我们说了，AOP是基于动态代理实现的，所以说我们如果直接获取Bean的类型，会发现不是原本的类型了：</p>
<div class="highlight"><pre><span></span><code><span class="n">Student</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">bean</span><span class="p">.</span><span class="na">getClass</span><span class="p">());</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/8lsiRj6Q9eTLhSI.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216172042146" src="https://s2.loli.net/2022/12/16/8lsiRj6Q9eTLhSI.png" /></a></p>
<p>这里其实是Spring通过CGLib为我们生成的动态代理类，也就不难理解为什么调用方法会直接得到增强之后的结果了。包括我们前面讲解Spring的异步任务调度时，为什么能够直接实现异步，其实就是利用了AOP机制实现的方法增强。</p>
<p>虽然这些功能已经非常强大了，但是仅仅只能简单的切入还是不能满足一些需求，在某些情况下，我们可以需求方法执行的一些参数，比如方法执行之后返回了什么，或是方法开始之前传入了什么参数等等，现在我们修改一下Student中<code>study</code>方法的参数：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">study</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">){</span><span class="w">  </span><span class="c1">//现在方法有一个String类型的参数</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;都别学Java了，根本找不到工作，快去卷&quot;</span><span class="o">+</span><span class="n">str</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>我们希望在增强的方法中也能拿到这个参数，然后进行处理：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentAOP</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterStudy</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//这个str参数我们该从哪里拿呢？</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;学什么&quot;</span><span class="o">+</span><span class="n">str</span><span class="o">+</span><span class="s">&quot;，Rust天下第一！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这个时候，我们可以为我们切入的方法添加一个JoinPoint参数，通过此参数就可以快速获取切点位置的一些信息：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterStudy</span><span class="p">(</span><span class="n">JoinPoint</span><span class="w"> </span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//JoinPoint实例会被自动传入</span>
<span class="w">    </span><span class="c1">//这里我们直接通过getArgs()返回的参数数组获取第1个参数</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;学什么&quot;</span><span class="o">+</span><span class="n">point</span><span class="p">.</span><span class="na">getArgs</span><span class="p">()</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">&quot;，Rust天下第一！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>接着我们修改一下刚刚的AOP配置（因为方法参数有变动）看看结果吧：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:pointcut</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="na">expression=</span><span class="s">&quot;execution(* org.example.entity.Student.study(String))&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>现在我们来测试一下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;application.xml&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">bean</span><span class="p">.</span><span class="na">study</span><span class="p">(</span><span class="s">&quot;PHP&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/NrZA49JvpgEyL2O.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216160501469" src="https://s2.loli.net/2022/12/16/NrZA49JvpgEyL2O.png" /></a></p>
<p>是不是感觉大部分功能都可以通过AOP来完成了？</p>
<p>我们接着来看自定义度更高的环绕方法，现在我们希望在方法执行前和执行后都加入各种各样的动作，如果还是一个一个切点写，有点太慢了，能不能直接写一起呢，此时我们就可以使用环绕方法。</p>
<p>环绕方法相当于完全代理了此方法，它完全将此方法包含在中间，需要我们手动调用才可以执行此方法，并且我们可以直接获取更多的参数：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">around</span><span class="p">(</span><span class="n">ProceedingJoinPoint</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;方法开始之前&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">proceed</span><span class="p">();</span><span class="w">   </span><span class="c1">//调用process方法来执行被代理的原方法，如果有返回值，可以使用value接收</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;方法执行完成，结果为：&quot;</span><span class="o">+</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>注意，如果代理方法存在返回值，那么环绕方法也需要有一个返回值，通过<code>proceed</code>方法来执行代理的方法，也可以修改参数之后调用<code>proceed(Object[])</code>，使用我们给定的参数再去执行：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">around</span><span class="p">(</span><span class="n">ProceedingJoinPoint</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;方法开始之前&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">getArgs</span><span class="p">()</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;伞兵一号&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">proceed</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="p">{</span><span class="n">arg</span><span class="p">});</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;方法执行完成，结果为：&quot;</span><span class="o">+</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这里我们还是以<code>study</code>方法为例，现在我们希望在调用前修改这个方法传入的参数值，改成我们自己的，然后在调用之后对返回值结果也进行处理：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">study</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;Java&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我的梦想是学Java&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我就要学Java，不要修改我的梦想！&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Java&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>现在我们编写一个环绕方法，对其进行全方面处理：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">around</span><span class="p">(</span><span class="n">ProceedingJoinPoint</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是她的家长，他不能学Java，必须学Rust，这是为他好&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">joinPoint</span><span class="p">.</span><span class="na">proceed</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="p">{</span><span class="s">&quot;Rust&quot;</span><span class="p">});</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;Java&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;听话，学Rust以后进大厂！&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Rust&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>同样的，因为方法变动了，现在我们去修改一下我们的AOP配置：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;aop:pointcut</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="na">expression=</span><span class="s">&quot;execution(* org.example.entity.Student.study(String))&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;aop:aspect</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;studentAOP&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;aop:around</span><span class="w"> </span><span class="na">method=</span><span class="s">&quot;around&quot;</span><span class="w"> </span><span class="na">pointcut-ref=</span><span class="s">&quot;test&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/aop:aspect&gt;</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/FPwQjRvsDgTnoWx.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216162003675" src="https://s2.loli.net/2022/12/16/FPwQjRvsDgTnoWx.png" /></a></p>
<p>细心的小伙伴可能会发现，环绕方法的图标是全包的，跟我们之前的图标不太一样。</p>
<p>现在我们来试试看吧：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;application.xml&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;已报名：&quot;</span><span class="o">+</span><span class="n">bean</span><span class="p">.</span><span class="na">study</span><span class="p">(</span><span class="s">&quot;Java&quot;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/pGl7n8qboe4tuJf.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216161855358" src="https://s2.loli.net/2022/12/16/pGl7n8qboe4tuJf.png" /></a></p>
<p>这样，我们就实现了环绕方法，通过合理利用AOP带来的便捷，可以使得我们的代码更加清爽和优美。这里介绍一下 AOP 领域中的特性术语，防止自己下来看不懂文章：</p>
<ul>
<li>通知（Advice）: AOP 框架中的增强处理，通知描述了切面何时执行以及如何执行增强处理，也就是我们上面编写的方法实现。</li>
<li>连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出，实际上就是我们在方法执行前或是执行后需要做的内容。</li>
<li>切点（PointCut）: 可以插入增强处理的连接点，可以是方法执行之前也可以方法执行之后，还可以是抛出异常之类的。</li>
<li>切面（Aspect）: 切面是通知和切点的结合，我们之前在xml中定义的就是切面，包括很多信息。</li>
<li>引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。</li>
<li>织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，我们之前都是在将我们的增强处理添加到目标对象，也就是织入（这名字挺有文艺范的）</li>
</ul>
<h3 id="aop_2">使用接口实现AOP<a class="headerlink" href="#aop_2" title="Permanent link">&para;</a></h3>
<p>前面我们介绍了如何使用xml配置一个AOP操作，这节课我们来看看如何使用Advice实现AOP。</p>
<p>它与我们之前学习的动态代理更接近一些，比如在方法开始执行之前或是执行之后会去调用我们实现的接口，首先我们需要将一个类实现Advice接口，只有实现此接口，才可以被通知，比如我们这里使用<code>MethodBeforeAdvice</code>表示是一个在方法执行之前的动作：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentAOP</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MethodBeforeAdvice</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">before</span><span class="p">(</span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;通过Advice实现AOP&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>我们发现，方法中包括了很多的参数，其中args代表的是方法执行前得到的实参列表，还有target表示执行此方法的实例对象。运行之后，效果和之前是一样的，但是在这里我们就可以快速获取到更多信息。还是以简单的study方法为例：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">study</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是学习方法！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;student&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;org.example.entity.Student&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;studentAOP&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;org.example.entity.StudentAOP&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;aop:config&gt;</span>
<span class="w">    </span><span class="nt">&lt;aop:pointcut</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;test&quot;</span><span class="w"> </span><span class="na">expression=</span><span class="s">&quot;execution(* org.example.entity.Student.study())&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="cm">&lt;!--  这里只需要添加我们刚刚写好的advisor就可以了，注意是Bean的名字  --&gt;</span>
<span class="w">    </span><span class="nt">&lt;aop:advisor</span><span class="w"> </span><span class="na">advice-ref=</span><span class="s">&quot;studentAOP&quot;</span><span class="w"> </span><span class="na">pointcut-ref=</span><span class="s">&quot;test&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/aop:config&gt;</span>
</code></pre></div>
<p>我们来测试一下吧：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/ofducpb2mLh9XHi.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216164110367" src="https://s2.loli.net/2022/12/16/ofducpb2mLh9XHi.png" /></a></p>
<p>除了此接口以外，还有其他的接口，比如<code>AfterReturningAdvice</code>就需要实现一个方法执行之后的操作：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentAOP</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MethodBeforeAdvice</span><span class="p">,</span><span class="w"> </span><span class="n">AfterReturningAdvice</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">before</span><span class="p">(</span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;通过Advice实现AOP&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterReturning</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">returnValue</span><span class="p">,</span><span class="w"> </span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是方法执行之后的结果，方法返回值为：&quot;</span><span class="o">+</span><span class="n">returnValue</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>因为使用的是接口，就非常方便，直接写一起，配置文件都不需要改了：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/DUZzqaBSiJKNv8j.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216164242506" src="https://s2.loli.net/2022/12/16/DUZzqaBSiJKNv8j.png" /></a></p>
<p>我们也可以使用MethodInterceptor（同样也是Advice的子接口）进行更加环绕那样的自定义的增强，它用起来就真的像代理一样，例子如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">study</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是学习方法！&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;lbwnb&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentAOP</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">MethodInterceptor</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//实现MethodInterceptor接口</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">invoke</span><span class="p">(</span><span class="n">MethodInvocation</span><span class="w"> </span><span class="n">invocation</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">//invoke方法就是代理方法</span>
<span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">invocation</span><span class="p">.</span><span class="na">proceed</span><span class="p">();</span><span class="w">   </span><span class="c1">//跟之前一样，需要手动proceed()才能调用原方法</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="o">+</span><span class="s">&quot;增强&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>我们来看看结果吧：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/ARcUW2mJrn7Y6f9.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216173211310" src="https://s2.loli.net/2022/12/16/ARcUW2mJrn7Y6f9.png" /></a></p>
<p>使用起来还是挺简单的。</p>
<h3 id="aop_3">使用注解实现AOP<a class="headerlink" href="#aop_3" title="Permanent link">&para;</a></h3>
<p>接着我们来看看如何使用注解实现AOP操作，现在变回我们之前的注解开发，首先我们需要在主类添加<code>@EnableAspectJAutoProxy</code>注解，开启AOP注解支持：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@EnableAspectJAutoProxy</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;org.example.entity&quot;</span><span class="p">)</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>还是熟悉的玩法，类上直接添加<code>@Component</code>快速注册Bean：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">study</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是学习方法！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>接着我们需要在定义AOP增强操作的类上添加<code>@Aspect</code>注解和<code>@Component</code>将其注册为Bean即可，就像我们之前在配置文件中也要将其注册为Bean那样：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StudentAOP</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>
</code></pre></div>
<p>接着，我们可以在里面编写增强方法，并将此方法添加到一个切点中，比如我们希望在Student的study方法执行之前执行我们的<code>before</code>方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">before</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是之前执行的内容！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>那么只需要添加@Before注解即可：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Before</span><span class="p">(</span><span class="s">&quot;execution(* org.example.entity.Student.study())&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">//execution写法跟之前一样</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">before</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是之前执行的内容！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这样，这个方法就会在指定方法执行之前执行了，是不是感觉比XML配置方便多了。我们来测试一下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">bean</span><span class="p">.</span><span class="na">study</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/16/KpiXcdNt7BglYQh.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221216165625372" src="https://s2.loli.net/2022/12/16/KpiXcdNt7BglYQh.png" /></a></p>
<p>同样的，我们可以为其添加<code>JoinPoint</code>参数来获取切入点信息，使用方法跟之前一样：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Before</span><span class="p">(</span><span class="s">&quot;execution(* org.example.entity.Student.study())&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">before</span><span class="p">(</span><span class="n">JoinPoint</span><span class="w"> </span><span class="n">point</span><span class="p">){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;参数列表：&quot;</span><span class="o">+</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">toString</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="na">getArgs</span><span class="p">()));</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是之前执行的内容！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>为了更方便，我们还可以直接将参数放入，比如：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">study</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是学习方法！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>使用命名绑定模式，可以快速得到原方法的参数：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Before</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;execution(* org.example.entity.Student.study(..)) &amp;&amp; args(str)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;str&quot;</span><span class="p">)</span>
<span class="c1">//命名绑定模式就是根据下面的方法参数列表进行匹配</span>
<span class="c1">//这里args指明参数，注意需要跟原方法保持一致，然后在argNames中指明</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">before</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="w">   </span><span class="c1">//可以快速得到传入的参数</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是之前执行的内容！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>除了@Before，还有很多可以直接使用的注解，比如@AfterReturning、@AfterThrowing等，比如@AfterReturning：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">study</span><span class="p">(){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是学习方法！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;lbwnb&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nd">@AfterReturning</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;execution(* org.example.entity.Student.study())&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;returnVal&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">returning</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;returnVal&quot;</span><span class="p">)</span><span class="w">   </span><span class="c1">//使用returning指定接收方法返回值的参数returnVal</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterReturn</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">returnVal</span><span class="p">){</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;返回值是：&quot;</span><span class="o">+</span><span class="n">returnVal</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>同样的，环绕也可以直接通过注解声明：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Around</span><span class="p">(</span><span class="s">&quot;execution(* com.test.bean.Student.test(..))&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">around</span><span class="p">(</span><span class="n">ProceedingJoinPoint</span><span class="w"> </span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;方法执行之前！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="na">proceed</span><span class="p">();</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;方法执行之后！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上，无论是使用注解或是XML配置，我们要做的流程都是一样的，在之后的学习中，我们还会遇到更多需要使用AOP的地方。</p>
<hr />
<h2 id="_9">数据库框架整合<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<p>学习了Spring之后，我们已经了解如何将一个类作为Bean交由IoC容器管理，这样，我们就可以通过更方便的方式来使用Mybatis框架，我们可以直接把SqlSessionFactory、Mapper交给Spring进行管理，并且可以通过注入的方式快速地使用它们。</p>
<p>因此，我们要学习一下如何将Mybatis与Spring进行整合，那么首先，我们需要在之前知识的基础上继续深化学习。</p>
<h3 id="_10">了解数据源<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>在之前，我们如果需要创建一个JDBC的连接，那么必须使用<code>DriverManager.getConnection()</code>来创建连接，连接建立后，我们才可以进行数据库操作。而学习了Mybatis之后，我们就不用再去使用<code>DriverManager</code>为我们提供连接对象，而是直接使用Mybatis为我们提供的<code>SqlSessionFactory</code>工具类来获取对应的<code>SqlSession</code>通过会话对象去操作数据库。</p>
<p>那么，它到底是如何封装JDBC的呢？我们可以试着来猜想一下，会不会是Mybatis每次都是帮助我们调用<code>DriverManager</code>来实现的数据库连接创建？我们可以看看Mybatis的源码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">SqlSession</span><span class="w"> </span><span class="nf">openSession</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">openSessionFromDataSource</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">configuration</span><span class="p">.</span><span class="na">getDefaultExecutorType</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="n">TransactionIsolationLevel</span><span class="p">)</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>在通过<code>SqlSessionFactory</code>调用<code>openSession</code>方法之后，它调用了内部的一个私有的方法<code>openSessionFromDataSource</code>，我们接着来看，这个方法里面定义了什么内容：</p>
<div class="highlight"><pre><span></span><code><span class="kd">private</span><span class="w"> </span><span class="n">SqlSession</span><span class="w"> </span><span class="nf">openSessionFromDataSource</span><span class="p">(</span><span class="n">ExecutorType</span><span class="w"> </span><span class="n">execType</span><span class="p">,</span><span class="w"> </span><span class="n">TransactionIsolationLevel</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Transaction</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="w">    </span><span class="n">DefaultSqlSession</span><span class="w"> </span><span class="n">var8</span><span class="p">;</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//获取当前环境（由配置文件映射的对象实体）</span>
<span class="w">        </span><span class="n">Environment</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">configuration</span><span class="p">.</span><span class="na">getEnvironment</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//事务工厂（暂时不提，下一板块讲解）</span>
<span class="w">        </span><span class="n">TransactionFactory</span><span class="w"> </span><span class="n">transactionFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getTransactionFactoryFromEnvironment</span><span class="p">(</span><span class="n">environment</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//配置文件中：&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span>
<span class="w">        </span><span class="c1">//生成事务（根据我们的配置，会默认生成JdbcTransaction），这里是关键，我们看到这里用到了environment.getDataSource()方法</span>
<span class="w">        </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transactionFactory</span><span class="p">.</span><span class="na">newTransaction</span><span class="p">(</span><span class="n">environment</span><span class="p">.</span><span class="na">getDataSource</span><span class="p">(),</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//执行器，包括全部的数据库操作方法定义，本质上是在使用执行器操作数据库，需要传入事务对象</span>
<span class="w">        </span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">configuration</span><span class="p">.</span><span class="na">newExecutor</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">execType</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//封装为SqlSession对象</span>
<span class="w">        </span><span class="n">var8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultSqlSession</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">configuration</span><span class="p">,</span><span class="w"> </span><span class="n">executor</span><span class="p">,</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">var12</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">closeTransaction</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">ExceptionFactory</span><span class="p">.</span><span class="na">wrapException</span><span class="p">(</span><span class="s">&quot;Error opening session.  Cause: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">var12</span><span class="p">,</span><span class="w"> </span><span class="n">var12</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ErrorContext</span><span class="p">.</span><span class="na">instance</span><span class="p">().</span><span class="na">reset</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">var8</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>也就是说，我们的数据源配置信息，存放在了<code>Transaction</code>对象中，那么现在我们只需要知道执行器到底是如何执行SQL语句的，我们就知道到底如何创建<code>Connection</code>对象了，这时就需要获取数据库的链接信息了，那么我们来看看，这个<code>DataSource</code>到底是个什么：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">DataSource</span><span class="w">  </span><span class="kd">extends</span><span class="w"> </span><span class="n">CommonDataSource</span><span class="p">,</span><span class="w"> </span><span class="n">Wrapper</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>

<span class="w">  </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">)</span>
<span class="w">    </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们发现，它是在<code>javax.sql</code>定义的一个接口，它包括了两个方法，都是用于获取连接的。因此，现在我们可以断定，并不是通过之前<code>DriverManager</code>的方法去获取连接了，而是使用<code>DataSource</code>的实现类来获取的，因此，也就正式引入到我们这一节的话题了：</p>
<blockquote>
<p>数据库链接的建立和关闭是极其耗费系统资源的操作，通过DriverManager获取的数据库连接，一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完后立即关闭连接，频繁的打开、关闭连接会持续消耗网络资源，造成整个系统性能的低下。</p>
</blockquote>
<p>因此，JDBC为我们定义了一个数据源的标准，也就是<code>DataSource</code>接口，告诉数据源数据库的连接信息，并将所有的连接全部交给数据源进行集中管理，当需要一个<code>Connection</code>对象时，可以向数据源申请，数据源会根据内部机制，合理地分配连接对象给我们。</p>
<p>一般比较常用的<code>DataSource</code>实现，都是采用池化技术，就是在一开始就创建好N个连接，这样之后使用就无需再次进行连接，而是直接使用现成的<code>Connection</code>对象进行数据库操作。</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/rk4mcdvYn6osOLW.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217134119558" src="https://s2.loli.net/2022/12/17/rk4mcdvYn6osOLW.png" /></a></p>
<p>当然，也可以使用传统的即用即连的方式获取<code>Connection</code>对象，Mybatis为我们提供了几个默认的数据源实现，我们之前一直在使用的是官方的默认配置，也就是池化数据源：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="cp">&lt;!DOCTYPE configuration</span>
<span class="cp">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>
<span class="cp">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
<span class="w">    </span><span class="nt">&lt;environments</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;development&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;environment</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;development&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;transactionManager</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;JDBC&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;dataSource</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;POOLED&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;driver&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;${驱动类（含包名）}&quot;</span><span class="nt">/&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;url&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;${数据库连接URL}&quot;</span><span class="nt">/&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;username&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;${用户名}&quot;</span><span class="nt">/&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;password&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;${密码}&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/dataSource&gt;</span>
<span class="w">        </span><span class="nt">&lt;/environment&gt;</span>
<span class="w">    </span><span class="nt">&lt;/environments&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div>
<p>这里的<code>type</code>属性一共三个选项：</p>
<ul>
<li>UNPOOLED   不使用连接池的数据源</li>
<li>POOLED    使用连接池的数据源</li>
<li>JNDI     使用JNDI实现的数据源</li>
</ul>
<h3 id="mybatis">解读Mybatis数据源实现（选学）<a class="headerlink" href="#mybatis" title="Permanent link">&para;</a></h3>
<p>前面我们介绍了DataSource数据源，那么我们就来看看，Mybatis到底是怎么实现的。我们先来看看，不使用池化的数据源实现，它叫做<code>UnpooledDataSource</code>，我们来看看源码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">UnpooledDataSource</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">DataSource</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">ClassLoader</span><span class="w"> </span><span class="n">driverClassLoader</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Properties</span><span class="w"> </span><span class="n">driverProperties</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Driver</span><span class="o">&gt;</span><span class="w"> </span><span class="n">registeredDrivers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcurrentHashMap</span><span class="p">();</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">driver</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">url</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">username</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Boolean</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">defaultTransactionIsolationLevel</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">defaultNetworkTimeout</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>首先这个类中定义了很多的成员，包括数据库的连接信息、数据库驱动信息、事务相关信息等。我们接着来看，它是如何实现<code>DataSource</code>中提供的接口方法的：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">doGetConnection</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">username</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">password</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">public</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">doGetConnection</span><span class="p">(</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">password</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上，这两个方法都指向了内部的一个<code>doGetConnection</code>方法，那么我们接着来看：</p>
<div class="highlight"><pre><span></span><code><span class="kd">private</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">doGetConnection</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Properties</span><span class="w"> </span><span class="n">props</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Properties</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">driverProperties</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">props</span><span class="p">.</span><span class="na">putAll</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">driverProperties</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">username</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">props</span><span class="p">.</span><span class="na">setProperty</span><span class="p">(</span><span class="s">&quot;user&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">username</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">password</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">props</span><span class="p">.</span><span class="na">setProperty</span><span class="p">(</span><span class="s">&quot;password&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">password</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">doGetConnection</span><span class="p">(</span><span class="n">props</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这里将用户名和密码配置封装为一个Properties对象，然后执行另一个重载同名的方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">private</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">doGetConnection</span><span class="p">(</span><span class="n">Properties</span><span class="w"> </span><span class="n">properties</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//若未初始化驱动，需要先初始化，内部维护了一个Map来记录初始化信息，这里不多介绍了</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">initializeDriver</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//传统的获取连接的方式，是不是终于找到熟悉的味道了</span>
<span class="w">    </span><span class="n">Connection</span><span class="w"> </span><span class="n">connection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DriverManager</span><span class="p">.</span><span class="na">getConnection</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">url</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//对连接进行额外的一些配置</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">configureConnection</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">connection</span><span class="p">;</span><span class="w">   </span><span class="c1">//返回得到的Connection对象</span>
<span class="p">}</span>
</code></pre></div>
<p>到这里，就返回<code>Connection</code>对象了，而此对象正是通过<code>DriverManager</code>来创建的，因此，非池化的数据源实现依然使用的是传统的连接创建方式，那我们接着来看池化的数据源实现，它是<code>PooledDataSource</code>类：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">PooledDataSource</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">DataSource</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Log</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LogFactory</span><span class="p">.</span><span class="na">getLog</span><span class="p">(</span><span class="n">PooledDataSource</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">PoolState</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PoolState</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//内部维护了一个非池化的数据源，这是要干嘛？</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">UnpooledDataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">poolMaximumActiveConnections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">poolMaximumIdleConnections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">poolMaximumCheckoutTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20000</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">poolTimeToWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20000</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">poolMaximumLocalBadConnectionTolerance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">poolPingQuery</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;NO PING QUERY SET&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">poolPingEnabled</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">poolPingConnectionsNotUsedFor</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">expectedConnectionTypeCode</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//并发相关类，我们在JUC篇视频教程中介绍过，感兴趣可以前往观看</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Condition</span><span class="w"> </span><span class="n">condition</span><span class="p">;</span>
</code></pre></div>
<p>我们发现，在这里的定义就比非池化的实现复杂得多了，因为它还要考虑并发的问题，并且还要考虑如何合理地存放大量的链接对象，该如何进行合理分配，因此它的玩法非常之高级，但是，再高级的玩法，我们都要拿下。</p>
<p>首先注意，它存放了一个UnpooledDataSource，此对象是在构造时就被创建，其实创建Connection还是依靠数据库驱动创建，我们后面慢慢解析，首先我们来看看它是如何实现接口方法的：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">popConnection</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">dataSource</span><span class="p">.</span><span class="na">getUsername</span><span class="p">(),</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">dataSource</span><span class="p">.</span><span class="na">getPassword</span><span class="p">()).</span><span class="na">getProxyConnection</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">public</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">popConnection</span><span class="p">(</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">password</span><span class="p">).</span><span class="na">getProxyConnection</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>可以看到，它调用了<code>popConnection()</code>方法来获取连接对象，然后进行了一个代理，通过这方法名字我们可以猜测，有可能整个连接池就是一个类似于栈的集合类型结构实现的。那么我们接着来看看<code>popConnection</code>方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">private</span><span class="w"> </span><span class="n">PooledConnection</span><span class="w"> </span><span class="nf">popConnection</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">password</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">countedWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//返回的是PooledConnection对象，</span>
<span class="w">    </span><span class="n">PooledConnection</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">localBadConnectionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">conn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">synchronized</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//加锁，因为有可能很多个线程都需要获取连接对象</span>
<span class="w">            </span><span class="n">PoolState</span><span class="w"> </span><span class="n">var10000</span><span class="p">;</span>
<span class="w">            </span><span class="c1">//PoolState存了两个List，一个是空闲列表，一个是活跃列表</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">idleConnections</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//有空闲的连接时，可以直接分配Connection</span>
<span class="w">                </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PooledConnection</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">idleConnections</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">//ArrayList中取第一个元素</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Checked out connection &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; from pool.&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="c1">//如果已经没有多余的连接可以分配，那么就检查一下活跃连接数是否达到最大的分配上限，如果没有，就new一个新的</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">activeConnections</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">poolMaximumActiveConnections</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//注意new了之后并没有立即往List里面塞，只是存了一些基本信息</span>
<span class="w">                </span><span class="c1">//我们发现，这里依靠UnpooledDataSource创建了一个Connection对象，并将其封装到PooledConnection中</span>
<span class="w">                </span><span class="c1">//所以说内部维护的UnpooledDataSource对象其实是为了节省代码，因为创建数据库连接其实都是一样的方式</span>
<span class="w">                </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PooledConnection</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">dataSource</span><span class="p">.</span><span class="na">getConnection</span><span class="p">(),</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Created connection &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">              </span><span class="c1">//以上条件都不满足，那么只能从之前的连接中寻找了，看看有没有那种卡住的链接（比如，由于网络问题有可能之前的连接一直被卡住，然而正常情况下早就结束并且可以使用了，所以这里相当于是优化也算是一种捡漏的方式）</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//获取最早创建的连接</span>
<span class="w">                </span><span class="n">PooledConnection</span><span class="w"> </span><span class="n">oldestActiveConnection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PooledConnection</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">activeConnections</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">                </span><span class="kt">long</span><span class="w"> </span><span class="n">longestCheckoutTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">getCheckoutTime</span><span class="p">();</span>
<span class="w">                </span><span class="c1">//判断是否超过最大的使用时间</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">longestCheckoutTime</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="na">poolMaximumCheckoutTime</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">//超时统计信息（不重要）</span>
<span class="w">                    </span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">claimedOverdueConnectionCount</span><span class="p">;</span>
<span class="w">                    </span><span class="n">var10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">;</span>
<span class="w">                    </span><span class="n">var10000</span><span class="p">.</span><span class="na">accumulatedCheckoutTimeOfOverdueConnections</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">longestCheckoutTime</span><span class="p">;</span>
<span class="w">                    </span><span class="n">var10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">;</span>
<span class="w">                    </span><span class="n">var10000</span><span class="p">.</span><span class="na">accumulatedCheckoutTime</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">longestCheckoutTime</span><span class="p">;</span>
<span class="w">                    </span><span class="c1">//从活跃列表中移除此链接信息</span>
<span class="w">                    </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">activeConnections</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">oldestActiveConnection</span><span class="p">);</span>
<span class="w">                    </span><span class="c1">//如果开启事务，还需要回滚一下</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">getAutoCommit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">rollback</span><span class="p">();</span>
<span class="w">                        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">SQLException</span><span class="w"> </span><span class="n">var15</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Bad connection. Could not roll back&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="c1">//这里就根据之前的连接对象直接new一个新的连接（注意使用的还是之前的Connection对象，并没有创建新的对象，只是被重新封装了）</span>
<span class="w">                    </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PooledConnection</span><span class="p">(</span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">(),</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">setCreatedTimestamp</span><span class="p">(</span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">getCreatedTimestamp</span><span class="p">());</span>
<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">setLastUsedTimestamp</span><span class="p">(</span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">getLastUsedTimestamp</span><span class="p">());</span>
<span class="w">                    </span><span class="c1">//过期</span>
<span class="w">                    </span><span class="n">oldestActiveConnection</span><span class="p">.</span><span class="na">invalidate</span><span class="p">();</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Claimed overdue connection &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                  </span><span class="c1">//没有超时，那就确实是没连接可以用了，只能卡住了（阻塞）</span>
<span class="w">                  </span><span class="c1">//然后顺手记录一下目前有几个线程在等待其他的任务搞完</span>
<span class="w">                    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">countedWait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">hadToWaitCount</span><span class="p">;</span>
<span class="w">                            </span><span class="n">countedWait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Waiting as long as &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">poolTimeToWait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; milliseconds for connection.&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="c1">//最后再等等</span>
<span class="w">                        </span><span class="kt">long</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
<span class="w">                        </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">wait</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="na">poolTimeToWait</span><span class="p">);</span>
<span class="w">                        </span><span class="c1">//要是超过等待时间还是没等到，只能放弃了</span>
<span class="w">                        </span><span class="c1">//注意这样的话con就为null了</span>
<span class="w">                        </span><span class="n">var10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">;</span>
<span class="w">                        </span><span class="n">var10000</span><span class="p">.</span><span class="na">accumulatedWaitTime</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">wt</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">var16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">//经过之前的操作，并且已经成功分配到连接对象的情况下</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">conn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="na">isValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">//首先验证是否有效</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">getAutoCommit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">//清理之前可能存在的遗留事务操作</span>
<span class="w">                        </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">rollback</span><span class="p">();</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">setConnectionTypeCode</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">assembleConnectionTypeCode</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">dataSource</span><span class="p">.</span><span class="na">getUrl</span><span class="p">(),</span><span class="w"> </span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="n">password</span><span class="p">));</span>
<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">setCheckoutTimestamp</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">());</span>
<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">setLastUsedTimestamp</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">());</span>
<span class="w">                    </span><span class="c1">//添加到活跃表中</span>
<span class="w">                    </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">activeConnections</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
<span class="w">                    </span><span class="c1">//统计信息（不重要）</span>
<span class="w">                    </span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">requestCount</span><span class="p">;</span>
<span class="w">                    </span><span class="n">var10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">;</span>
<span class="w">                    </span><span class="n">var10000</span><span class="p">.</span><span class="na">accumulatedRequestTime</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">//无效的连接，直接抛异常</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;A bad connection (&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;) was returned from the pool, getting another connection.&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>

<span class="w">                    </span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">badConnectionCount</span><span class="p">;</span>
<span class="w">                    </span><span class="o">++</span><span class="n">localBadConnectionCount</span><span class="p">;</span>
<span class="w">                    </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">localBadConnectionCount</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">poolMaximumIdleConnections</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">poolMaximumLocalBadConnectionTolerance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>

<span class="w">                        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SQLException</span><span class="p">(</span><span class="s">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//最后该干嘛干嘛，要是之前拿到的con是null的话，直接抛异常</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">conn</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SQLException</span><span class="p">(</span><span class="s">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">conn</span><span class="p">;</span><span class="w">   </span><span class="c1">//否则正常返回</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>经过上面一顿猛如虎的操作之后，我们可以得到以下信息：</p>
<blockquote>
<p>如果最后得到了连接对象（有可能是从空闲列表中得到，有可能是直接创建的新的，还有可能是经过回收策略回收得到的），那么连接(Connection)对象一定会被放在活跃列表中(state.activeConnections)</p>
</blockquote>
<p>那么肯定有一个疑问，现在我们已经知道获取一个链接会直接进入到活跃列表中，那么，如果一个连接被关闭，又会发生什么事情呢，我们来看看此方法返回之后，会调用<code>getProxyConnection</code>来获取一个代理对象，实际上就是<code>PooledConnection</code>类：</p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">PooledConnection</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">InvocationHandler</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">CLOSE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;close&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Class</span><span class="o">&lt;?&gt;[]</span><span class="w"> </span><span class="n">IFACES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Class</span><span class="o">[]</span><span class="p">{</span><span class="n">Connection</span><span class="p">.</span><span class="na">class</span><span class="p">};</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hashCode</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//会记录是来自哪一个数据源创建的的</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">PooledDataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//连接对象本体</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="n">realConnection</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//代理的链接对象</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="n">proxyConnection</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>它直接代理了构造方法中传入的Connection对象，也是使用JDK的动态代理实现的，那么我们来看一下，它是如何进行代理的：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">invoke</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">proxy</span><span class="p">,</span><span class="w"> </span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Throwable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">methodName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">method</span><span class="p">.</span><span class="na">getName</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//如果调用的是Connection对象的close方法，</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">methodName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//这里并不会真的关闭连接（这也是为什么用代理），而是调用之前数据源的pushConnection方法，将此连接改为为空闲状态</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">dataSource</span><span class="p">.</span><span class="na">pushConnection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Object</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">method</span><span class="p">.</span><span class="na">getDeclaringClass</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">checkConnection</span><span class="p">();</span>
<span class="w">                </span><span class="c1">//任何操作执行之前都会检查连接是否可用</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">//原方法该干嘛干嘛</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">method</span><span class="p">.</span><span class="na">invoke</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">realConnection</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">var6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">ExceptionUtil</span><span class="p">.</span><span class="na">unwrapThrowable</span><span class="p">(</span><span class="n">var6</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这下，池化数据源的大致流程其实就已经很清晰了，那么我们最后再来看看<code>pushConnection</code>方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">pushConnection</span><span class="p">(</span><span class="n">PooledConnection</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">synchronized</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//老规矩，先来把锁</span>
<span class="w">        </span><span class="c1">//先从活跃列表移除此连接</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">activeConnections</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//判断此链接是否可用</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="na">isValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PoolState</span><span class="w"> </span><span class="n">var10000</span><span class="p">;</span>
<span class="w">            </span><span class="c1">//看看闲置列表容量是否已满（容量满了就回不去了）</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">idleConnections</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">poolMaximumIdleConnections</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getConnectionTypeCode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">expectedConnectionTypeCode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">var10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">;</span>
<span class="w">                </span><span class="n">var10000</span><span class="p">.</span><span class="na">accumulatedCheckoutTime</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getCheckoutTime</span><span class="p">();</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">getAutoCommit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">rollback</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="c1">//把唯一有用的Connection对象拿出来，然后重新创建一个PooledConnection包装</span>
<span class="w">                </span><span class="n">PooledConnection</span><span class="w"> </span><span class="n">newConn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PooledConnection</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">(),</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">                </span><span class="c1">//放入闲置列表，成功回收</span>
<span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">idleConnections</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">newConn</span><span class="p">);</span>
<span class="w">                </span><span class="n">newConn</span><span class="p">.</span><span class="na">setCreatedTimestamp</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="na">getCreatedTimestamp</span><span class="p">());</span>
<span class="w">                </span><span class="n">newConn</span><span class="p">.</span><span class="na">setLastUsedTimestamp</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="na">getLastUsedTimestamp</span><span class="p">());</span>
<span class="w">                </span><span class="n">conn</span><span class="p">.</span><span class="na">invalidate</span><span class="p">();</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Returned connection &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">newConn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; to pool.&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">var10000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">;</span>
<span class="w">                </span><span class="n">var10000</span><span class="p">.</span><span class="na">accumulatedCheckoutTime</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getCheckoutTime</span><span class="p">();</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">getAutoCommit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">rollback</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealConnection</span><span class="p">().</span><span class="na">close</span><span class="p">();</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Closed connection &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">conn</span><span class="p">.</span><span class="na">invalidate</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;A bad connection (&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">conn</span><span class="p">.</span><span class="na">getRealHashCode</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;) attempted to return to the pool, discarding connection.&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="na">state</span><span class="p">.</span><span class="na">badConnectionCount</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这样，我们就已经完全了解了Mybatis的池化数据源的执行流程了。只不过，无论Connection管理方式如何变换，无论数据源再高级，我们要知道，它都最终都会使用<code>DriverManager</code>来创建连接对象，而最终使用的也是<code>DriverManager</code>提供的<code>Connection</code>对象。</p>
<h3 id="mybatis_1">整合Mybatis框架<a class="headerlink" href="#mybatis_1" title="Permanent link">&para;</a></h3>
<p>通过了解数据源，我们已经清楚，Mybatis实际上是在使用自己编写的数据源（数据源实现其实有很多，之后我们再聊其他的）默认使用的是池化数据源，它预先存储了很多的连接对象。</p>
<p>那么我们来看一下，如何将Mybatis与Spring更好的结合呢，比如我们现在希望将SqlSessionFactory交给IoC容器进行管理，而不是我们自己创建工具类来管理（我们之前一直都在使用工具类管理和创建会话）</p>
<div class="highlight"><pre><span></span><code><span class="cm">&lt;!-- 这两个依赖不用我说了吧 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.mybatis<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>mybatis<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="cm">&lt;!-- 注意，对于Spring 6.0来说，版本需要在3.5以上 --&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>3.5.13<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>com.mysql<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>mysql-connector-j<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>8.0.31<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="cm">&lt;!-- Mybatis针对于Spring专门编写的支持框架 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.mybatis<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>mybatis-spring<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>3.0.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="cm">&lt;!-- Spring的JDBC支持框架 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
<span class="w">     </span><span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
<span class="w">     </span><span class="nt">&lt;artifactId&gt;</span>spring-jdbc<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">     </span><span class="nt">&lt;version&gt;</span>6.0.10<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p>在mybatis-spring依赖中，为我们提供了SqlSessionTemplate类，它其实就是官方封装的一个工具类，我们可以将其注册为Bean，这样我们随时都可以向IoC容器索要对象，而不用自己再去编写一个工具类了，我们可以直接在配置类中创建。对于这种别人编写的类型，如果要注册为Bean，那么只能在配置类中完成：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;org.example.entity&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//注册SqlSessionTemplate的Bean</span>
<span class="w">    </span><span class="nd">@Bean</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">SqlSessionTemplate</span><span class="w"> </span><span class="nf">sqlSessionTemplate</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">IOException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SqlSessionFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SqlSessionFactoryBuilder</span><span class="p">().</span><span class="na">build</span><span class="p">(</span><span class="n">Resources</span><span class="p">.</span><span class="na">getResourceAsReader</span><span class="p">(</span><span class="s">&quot;mybatis-config.xml&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SqlSessionTemplate</span><span class="p">(</span><span class="n">factory</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这里随便编写一个测试的Mapper类：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Data</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sid</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">sex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">TestMapper</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Select</span><span class="p">(</span><span class="s">&quot;select * from student where sid = 1&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="nf">getStudent</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>最后是配置文件：</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="cp">&lt;!DOCTYPE configuration</span>
<span class="cp">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>
<span class="cp">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
<span class="w">    </span><span class="nt">&lt;environments</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;development&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;environment</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;development&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;transactionManager</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;JDBC&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;dataSource</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;POOLED&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;driver&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="nt">/&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;url&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;jdbc:mysql://localhost:3306/study&quot;</span><span class="nt">/&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;username&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;root&quot;</span><span class="nt">/&gt;</span>
<span class="w">                </span><span class="nt">&lt;property</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;password&quot;</span><span class="w"> </span><span class="na">value=</span><span class="s">&quot;123456&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/dataSource&gt;</span>
<span class="w">        </span><span class="nt">&lt;/environment&gt;</span>
<span class="w">    </span><span class="nt">&lt;/environments&gt;</span>
<span class="w">    </span><span class="nt">&lt;mappers&gt;</span>
<span class="w">        </span><span class="nt">&lt;mapper</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;org.example.mapper.TestMapper&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/mappers&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div>
<p>我们来测试一下吧：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">SqlSessionTemplate</span><span class="w"> </span><span class="n">template</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">SqlSessionTemplate</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">TestMapper</span><span class="w"> </span><span class="n">testMapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">template</span><span class="p">.</span><span class="na">getMapper</span><span class="p">(</span><span class="n">TestMapper</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">testMapper</span><span class="p">.</span><span class="na">getStudent</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/L83vrESxoXKO7fQ.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217142651610" src="https://s2.loli.net/2022/12/17/L83vrESxoXKO7fQ.png" /></a></p>
<p>这样，我们就成功将Mybatis与Spring完成了初步整合，直接从容器中就能获取到SqlSessionTemplate，结合自动注入，我们的代码量能够进一步的减少。</p>
<p>虽然这样已经很方便了，但是还不够方便，我们依然需要手动去获取Mapper对象，那么能否直接得到对应的Mapper对象呢，我们希望让Spring直接帮助我们管理所有的Mapper，当需要时，可以直接从容器中获取，我们可以直接在配置类上方添加注解：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;org.example.entity&quot;</span><span class="p">)</span>
<span class="nd">@MapperScan</span><span class="p">(</span><span class="s">&quot;org.example.mapper&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>
<p>这样，Mybatis就会自动扫描对应包下所有的接口，并直接被注册为对应的Mapper作为Bean管理，那么我们现在就可以直接通过容器获取了：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">TestMapper</span><span class="w"> </span><span class="n">mapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">TestMapper</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">mapper</span><span class="p">.</span><span class="na">getStudent</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<p>在我们后续的SpringBoot学习阶段，会有更加方便的方式来注册Mapper，我们只需要一个<code>@Mapper</code>注解即可完成，非常简单。</p>
<p>请一定注意，必须存在<code>SqlSessionTemplate</code>或是<code>SqlSessionFactoryBean</code>的Bean，否则会无法初始化（毕竟要数据库的链接信息）我们接着来看，如果我们希望直接去除Mybatis的配置文件，完全实现全注解配置，那么改怎么去实现呢？我们可以使用<code>SqlSessionFactoryBean</code>类：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;org.example.entity&quot;</span><span class="p">)</span>
<span class="nd">@MapperScan</span><span class="p">(</span><span class="s">&quot;org.example.mapper&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Bean</span><span class="w">   </span><span class="c1">//单独创建一个Bean，方便之后更换</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">DataSource</span><span class="w"> </span><span class="nf">dataSource</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PooledDataSource</span><span class="p">(</span><span class="s">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;jdbc:mysql://localhost:3306/study&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;root&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;123456&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Bean</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">SqlSessionFactoryBean</span><span class="w"> </span><span class="nf">sqlSessionFactoryBean</span><span class="p">(</span><span class="n">DataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="p">){</span><span class="w">  </span><span class="c1">//直接参数得到Bean对象</span>
<span class="w">        </span><span class="n">SqlSessionFactoryBean</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SqlSessionFactoryBean</span><span class="p">();</span>
<span class="w">        </span><span class="n">bean</span><span class="p">.</span><span class="na">setDataSource</span><span class="p">(</span><span class="n">dataSource</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>首先我们需要创建一个数据源的实现类，因为这是数据库最基本的信息，然后再给到<code>SqlSessionFactoryBean</code>实例，这样，我们相当于直接在一开始通过IoC容器配置了<code>SqlSessionFactory</code>，这里只需要传入一个<code>DataSource</code>的实现即可，我们采用池化数据源。</p>
<p>删除配置文件，重新再来运行，同样可以正常使用Mapper。从这里开始，通过IoC容器，Mybatis已经不再需要使用配置文件了，在我们之后的学习中，基于Spring的开发将不会再出现Mybatis的配置文件。</p>
<h3 id="hikaricp">使用HikariCP连接池<a class="headerlink" href="#hikaricp" title="Permanent link">&para;</a></h3>
<p>前面我们提到了数据源还有其他实现，比如C3P0、Druid等，它们都是非常优秀的数据源实现（可以自行了解），不过我们这里要介绍的，是之后在SpringBoot中还会遇到的HikariCP连接池。</p>
<blockquote>
<p>HikariCP是由日本程序员开源的一个数据库连接池组件，代码非常轻量，并且速度非常的快。根据官方提供的数据，在酷睿i7开启32个线程32个连接的情况下，进行随机数据库读写操作，HikariCP的速度是现在常用的C3P0数据库连接池的数百倍。在SpringBoot 3.0中，官方也是推荐使用HikariCP。</p>
</blockquote>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/Q6gPI9RVe1X7Noq.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217145126777" src="https://s2.loli.net/2022/12/17/Q6gPI9RVe1X7Noq.png" /></a></p>
<p>首先，我们需要导入依赖：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>com.zaxxer<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>HikariCP<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>5.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p>要更换数据源实现，非常简单，我们可以直接声明一个Bean：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Bean</span>
<span class="kd">public</span><span class="w"> </span><span class="n">DataSource</span><span class="w"> </span><span class="nf">dataSource</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">HikariDataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HikariDataSource</span><span class="p">();</span>
<span class="w">    </span><span class="n">dataSource</span><span class="p">.</span><span class="na">setJdbcUrl</span><span class="p">(</span><span class="s">&quot;jdbc:mysql://localhost:3306/study&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">dataSource</span><span class="p">.</span><span class="na">setDriverClassName</span><span class="p">(</span><span class="s">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">dataSource</span><span class="p">.</span><span class="na">setUsername</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">dataSource</span><span class="p">.</span><span class="na">setPassword</span><span class="p">(</span><span class="s">&quot;123456&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dataSource</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>最后我们发现，同样可以得到输出结果，但是出现了一个报错：</p>
<div class="highlight"><pre><span></span><code>SLF4J: No SLF4J providers were found.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#noProviders for further details.
</code></pre></div>
<p>此数据源实际上是采用了SLF4J日志框架打印日志信息，但是现在没有任何的日志实现（slf4j只是一个API标准，它规范了多种日志框架的操作，统一使用SLF4J定义的方法来操作不同的日志框架，我们会在SpringBoot篇进行详细介绍）我们这里就使用JUL作为日志实现，我们需要导入另一个依赖：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.slf4j<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>slf4j-jdk14<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>1.7.25<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p>注意版本一定要和<code>slf4j-api</code>保持一致，我们可以在这里直接查看：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/93OSknRKXwdZsp7.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217154216832" src="https://s2.loli.net/2022/12/17/93OSknRKXwdZsp7.png" /></a></p>
<p>这样，HikariCP数据源的启动日志就可以正常打印出来了：</p>
<div class="highlight"><pre><span></span><code>12月 17, 2022 3:41:38 下午 com.zaxxer.hikari.HikariDataSource getConnection
信息: HikariPool-1 - Starting...
12月 17, 2022 3:41:38 下午 com.zaxxer.hikari.pool.HikariPool checkFailFast
信息: HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@4f8969b0
12月 17, 2022 3:41:38 下午 com.zaxxer.hikari.HikariDataSource getConnection
信息: HikariPool-1 - Start completed.
Student(sid=1, name=小明, sex=男)
</code></pre></div>
<p>在SpringBoot阶段，我们还会遇到<code>HikariPool-1 - Starting...</code>和<code>HikariPool-1 - Start completed.</code>同款日志信息。</p>
<p>当然，Lombok肯定也是支持这个日志框架快速注解的：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Slf4j</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">MainConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="n">TestMapper</span><span class="w"> </span><span class="n">mapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">TestMapper</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="n">mapper</span><span class="p">.</span><span class="na">getStudent</span><span class="p">().</span><span class="na">toString</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>是不是感觉特别方便？</p>
<h3 id="mybatis_2">Mybatis事务管理<a class="headerlink" href="#mybatis_2" title="Permanent link">&para;</a></h3>
<p>我们前面已经讲解了如何让Mybatis与Spring更好地融合在一起，通过将对应的Bean类型注册到容器中，就能更加方便的去使用Mapper，那么现在，我们接着来看Spring的事务控制。</p>
<p>在开始之前，我们还是回顾一下事务机制。首先事务遵循一个ACID原则：</p>
<ul>
<li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。类比银行转账，从一个账号扣款，另一个账号增款，必须保证总金额不变。</li>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。类比多个人同时编辑同一文档，每个人看到的结果都是独立的，不会受其他人的影响，不过难免会存在冲突。</li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。类比写入硬盘的文件，即使关机重启，文件仍然存在。</li>
</ul>
<p>简单来说，事务就是要么完成，要么就啥都别做！并且不同的事务之间相互隔离，互不干扰。</p>
<p>那么我们接着来深入了解一下事务的<strong>隔离机制</strong>（在之前数据库入门阶段并没有提到）我们说了，事务之间是相互隔离互不干扰的，那么如果出现了下面的情况，会怎么样呢：</p>
<blockquote>
<p>当两个事务同时在执行，并且同时在操作同一个数据，这样很容易出现并发相关的问题，比如一个事务先读取了某条数据，而另一个事务此时修改了此数据，当前一个事务紧接着再次读取时，会导致和前一次读取的数据不一致，这就是一种典型的数据虚读现象。</p>
</blockquote>
<p>因此，为了解决这些问题，事务之间实际上是存在一些隔离级别的：</p>
<ul>
<li>ISOLATION_READ_UNCOMMITTED（读未提交）：其他事务会读取当前事务尚未更改的提交（相当于读取的是这个事务暂时缓存的内容，并不是数据库中的内容）</li>
<li>ISOLATION_READ_COMMITTED（读已提交）：其他事务会读取当前事务已经提交的数据（也就是直接读取数据库中已经发生更改的内容）</li>
<li>ISOLATION_REPEATABLE_READ（可重复读）：其他事务会读取当前事务已经提交的数据并且其他事务执行过程中不允许再进行数据修改（注意这里仅仅是不允许修改数据）</li>
<li>ISOLATION_SERIALIZABLE（串行化）：它完全服从ACID原则，一个事务必须等待其他事务结束之后才能开始执行，相当于挨个执行，效率很低</li>
</ul>
<p>我们依次来看看，不同的隔离级别会导致什么问题。首先是<code>读未提交</code>级别，此级别属于最低级别，相当于各个事务共享一个缓存区域，任何事务的操作都在这里进行。那么它会导致以下问题：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/hQpluLA2bFKo1O8.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217155511058" src="https://s2.loli.net/2022/12/17/hQpluLA2bFKo1O8.png" /></a></p>
<p>也就是说，事务A最后得到的实际上是一个毫无意义的数据（事务B已经回滚了）我们称此数据为"脏数据"，这种现象称为<strong>脏读</strong></p>
<p>我们接着来看<code>读已提交</code>级别，事务只能读取其他事务已经提交的内容，相当于直接从数据中读取数据，这样就可以避免<strong>脏读</strong>问题了，但是它还是存在以下问题：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/K1sJbDNyudOgAcV.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217155538073" src="https://s2.loli.net/2022/12/17/K1sJbDNyudOgAcV.png" /></a></p>
<p>这正是我们前面例子中提到的问题，虽然它避免了脏读问题，但是如果事件B修改并提交了数据，那么实际上事务A之前读取到的数据依然不是最新的数据，直接导致两次读取的数据不一致，这种现象称为<strong>虚读</strong>也可以称为<strong>不可重复读</strong></p>
<p>因此，下一个隔离级别<code>可重复读</code>就能够解决这样的问题（MySQL的默认隔离级别），它规定在其他事务执行时，不允许修改数据，这样，就可以有效地避免不可重复读的问题，但是这样就一定安全了吗？这里仅仅是禁止了事务执行过程中的UPDATE操作，但是它并没有禁止INSERT这类操作，因此，如果事务A执行过程中事务B插入了新的数据，那么A这时是毫不知情的，比如：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/uwiHT8AcobeBjL3.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217160023674" src="https://s2.loli.net/2022/12/17/uwiHT8AcobeBjL3.png" /></a></p>
<p>两个人同时报名一个活动，两个报名的事务同时在进行，但是他们一开始读取到的人数都是5，而这时，它们都会认为报名成功后人数应该变成6，而正常情况下应该是7，因此这个时候就发生了数据的<strong>幻读</strong>现象。</p>
<p>因此，要解决这种问题，只能使用最后一种隔离级别<code>串行化</code>来实现了，每个事务不能同时进行，直接避免所有并发问题，简单粗暴，但是效率爆减，并不推荐。</p>
<p>最后总结三种情况：</p>
<ul>
<li>脏读：读取到了被回滚的数据，它毫无意义。</li>
<li>虚读（不可重复读）：由于其他事务更新数据，两次读取的数据不一致。</li>
<li>幻读：由于其他事务执行插入删除操作，而又无法感知到表中记录条数发生变化，当下次再读取时会莫名其妙多出或缺失数据，就像产生幻觉一样。</li>
</ul>
<p>（对于虚读和幻读的区分：虚读是某个数据前后读取不一致，幻读是整个表的记录数量前后读取不一致</p>
<p>最后这张图，请务必记在你的脑海，记在你的心中：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/nHfV8R1ZUybTSd2.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217160052616" src="https://s2.loli.net/2022/12/17/nHfV8R1ZUybTSd2.png" /></a></p>
<p>Mybatis对于数据库的事务管理，也有着相应的封装。一个事务无非就是创建、提交、回滚、关闭，因此这些操作被Mybatis抽象为一个接口：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Transaction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">commit</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">rollback</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">close</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>

<span class="w">    </span><span class="n">Integer</span><span class="w"> </span><span class="nf">getTimeout</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>对于此接口的实现，MyBatis的事务管理分为两种形式：</p>
<ol>
<li>使用<strong>JDBC</strong>的事务管理机制：即利用对应数据库的驱动生成的<code>Connection</code>对象完成对事务的提交（commit()）、回滚（rollback()）、关闭（close()）等，对应的实现类为<code>JdbcTransaction</code></li>
<li>使用<strong>MANAGED</strong>的事务管理机制：这种机制MyBatis自身不会去实现事务管理，而是让程序的容器（比如Spring）来实现对事务的管理，对应的实现类为<code>ManagedTransaction</code></li>
<li>如果需要自定义，那么得实现<code>org.apache.ibatis.transaction.Transaction</code>接口，然后在<code>type</code>属性中指定其类名。使用自定义的事务管理器可以根据具体需求来实现一些特定的事务管理行为。</li>
</ol>
<p>而我们之前一直使用的其实就是JDBC的事务，相当于直接使用<code>Connection</code>对象（之前JavaWeb阶段已经讲解过了）在进行事务操作，并没有额外的管理机制，对应的配置为：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;transactionManager</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;JDBC&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>
<p>那么我们来看看<code>JdbcTransaction</code>是不是像我们上面所说的那样管理事务的，直接上源码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">JdbcTransaction</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Transaction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Log</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LogFactory</span><span class="p">.</span><span class="na">getLog</span><span class="p">(</span><span class="n">JdbcTransaction</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="n">connection</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">DataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">TransactionIsolationLevel</span><span class="w"> </span><span class="n">level</span><span class="p">;</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">autoCommit</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">JdbcTransaction</span><span class="p">(</span><span class="n">DataSource</span><span class="w"> </span><span class="n">ds</span><span class="p">,</span><span class="w"> </span><span class="n">TransactionIsolationLevel</span><span class="w"> </span><span class="n">desiredLevel</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">desiredAutoCommit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//数据源</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">dataSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ds</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//事务隔离级别，上面已经提到过了</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desiredLevel</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//是否自动提交</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">autoCommit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">desiredAutoCommit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//也可以直接给个Connection对象</span>
<span class="w">   </span><span class="kd">public</span><span class="w"> </span><span class="nf">JdbcTransaction</span><span class="p">(</span><span class="n">Connection</span><span class="w"> </span><span class="n">connection</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connection</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getConnection</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//没有就通过数据源新开一个Connection</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">openConnection</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">commit</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//连接已经创建并且没开启自动提交才可以使用</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="p">.</span><span class="na">getAutoCommit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">log</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Committing JDBC Connection [&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">                        </span><span class="c1">//实际上使用的是数据库驱动提供的Connection对象进行事务操作</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">connection</span><span class="p">.</span><span class="na">commit</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>相当于<code>JdbcTransaction</code>只是为数据库驱动提供的<code>Connection</code>对象套了层壳，所有的事务操作实际上是直接调用<code>Connection</code>对象。那么我们接着来看<code>ManagedTransaction</code>的源码：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ManagedTransaction</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Transaction</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">commit</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">rollback</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">SQLException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>我们发现，大体内容和<code>JdbcTransaction</code>差不多，但是它并没有实现任何的事务操作。也就是说，它希望将实现交给其他的管理框架来完成，而Spring就为Mybatis提供了一个非常好的事务管理实现。</p>
<h3 id="spring_3">使用Spring事务管理<a class="headerlink" href="#spring_3" title="Permanent link">&para;</a></h3>
<p>现在我们来学习一下Spring提供的事务管理（Spring事务管理分为编程式事务和声明式事务，但是编程式事务过于复杂并且具有高度耦合性，违背了Spring框架的设计初衷，因此这里只讲解声明式事务）声明式事务是基于AOP实现的。</p>
<p>使用声明式事务非常简单，我们只需要在配置类添加<code>@EnableTransactionManagement</code>注解即可，这样就可以开启Spring的事务支持了。接着，我们只需要把一个事务要做的所有事情封装到Service层的一个方法中即可，首先需要在配置文件中注册一个新的Bean，事务需要执行必须有一个事务管理器：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="p">(</span><span class="s">&quot;org.example&quot;</span><span class="p">)</span>
<span class="nd">@MapperScan</span><span class="p">(</span><span class="s">&quot;org.example.mapper&quot;</span><span class="p">)</span>
<span class="nd">@EnableTransactionManagement</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainConfiguration</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Bean</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">TransactionManager</span><span class="w"> </span><span class="nf">transactionManager</span><span class="p">(</span><span class="n">DataSource</span><span class="w"> </span><span class="n">dataSource</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DataSourceTransactionManager</span><span class="p">(</span><span class="n">dataSource</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>接着我们来编写一个简单的Mapper操作：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Mapper</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">TestMapper</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="nd">@Insert</span><span class="p">(</span><span class="s">&quot;insert into student(name, sex) values(&#39;测试&#39;, &#39;男&#39;)&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">insertStudent</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>这样会向数据库中插入一条新的学生信息，接着，假设我们这里有一个业务需要连续插入两条学生信息，首先编写业务层的接口：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">TestService</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>接着，我们再来编写业务层的实现，我们可以直接将其注册为Bean，交给Spring来进行管理，这样就可以自动将Mapper注入到类中了，并且可以支持事务：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">TestService</span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Resource</span>
<span class="w">    </span><span class="n">TestMapper</span><span class="w"> </span><span class="n">mapper</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Transactional</span><span class="w">   </span><span class="c1">//此注解表示事务，之后执行的所有方法都会在同一个事务中执行</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mapper</span><span class="p">.</span><span class="na">insertStudent</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;我是测试异常！&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">mapper</span><span class="p">.</span><span class="na">insertStudent</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>我们只需在方法上添加<code>@Transactional</code>注解，即可表示此方法执行的是一个事务操作，在调用此方法时，Spring会通过AOP机制为其进行增强，一旦发现异常，事务会自动回滚。最后我们来调用一下此方法：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Slf4j</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&quot;项目正在启动...&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">TestConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="n">TestService</span><span class="w"> </span><span class="n">service</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">TestService</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="n">service</span><span class="p">.</span><span class="na">test</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>得到的结果是出现错误：</p>
<div class="highlight"><pre><span></span><code>12月 17, 2022 4:09:00 下午 com.zaxxer.hikari.HikariDataSource getConnection
信息: HikariPool-1 - Start completed.
Exception in thread &quot;main&quot; java.lang.RuntimeException: 我是测试异常！
    at org.example.service.TestServiceImpl.test(TestServiceImpl.java:17)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:568)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)
</code></pre></div>
<p>我们发现，整个栈追踪信息中包含了大量aop包下的内容，也就印证了它确实是通过AOP实现的，那么我们接着来看一下，数据库中的数据是否没有发生变化（出现异常回滚了）</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/TQDbpK2JVP3d9wz.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217161027254" src="https://s2.loli.net/2022/12/17/TQDbpK2JVP3d9wz.png" /></a></p>
<p>结果显而易见，第一次的插入操作确实被回滚了，数据库中没有任何新增的内容。</p>
<p>我们接着来研究一下<code>@Transactional</code>注解的一些参数：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Target</span><span class="p">({</span><span class="n">ElementType</span><span class="p">.</span><span class="na">TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">ElementType</span><span class="p">.</span><span class="na">METHOD</span><span class="p">})</span>
<span class="nd">@Retention</span><span class="p">(</span><span class="n">RetentionPolicy</span><span class="p">.</span><span class="na">RUNTIME</span><span class="p">)</span>
<span class="nd">@Inherited</span>
<span class="nd">@Documented</span>
<span class="kd">public</span><span class="w"> </span><span class="nd">@interface</span><span class="w"> </span><span class="n">Transactional</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@AliasFor</span><span class="p">(</span><span class="s">&quot;transactionManager&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="nf">value</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@AliasFor</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="nf">transactionManager</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="nf">label</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="n">Propagation</span><span class="w"> </span><span class="nf">propagation</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">Propagation</span><span class="p">.</span><span class="na">REQUIRED</span><span class="p">;</span>

<span class="w">    </span><span class="n">Isolation</span><span class="w"> </span><span class="nf">isolation</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">Isolation</span><span class="p">.</span><span class="na">DEFAULT</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">timeout</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="nf">timeoutString</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">readOnly</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">Class</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Throwable</span><span class="o">&gt;[]</span><span class="w"> </span><span class="nf">rollbackFor</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="nf">rollbackForClassName</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="n">Class</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Throwable</span><span class="o">&gt;[]</span><span class="w"> </span><span class="nf">noRollbackFor</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="nf">noRollbackForClassName</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>
<p>我们来讲解几个比较关键的属性：</p>
<ul>
<li>transactionManager：指定事务管理器</li>
<li>propagation：事务传播规则，一个事务可以包括N个子事务</li>
<li>isolation：事务隔离级别，不多说了</li>
<li>timeout：事务超时时间</li>
<li>readOnly：是否为只读事务，不同的数据库会根据只读属性进行优化，比如MySQL一旦声明事务为只读，那么久不允许增删改操作了。</li>
<li>rollbackFor和noRollbackFor：发生指定异常时回滚或是不回滚，默认发生任何异常都回滚。</li>
</ul>
<p>除了事务的传播规则，其他的内容其实已经给大家讲解过了，那么我们就来看看事务的传播。事务传播一共有七种级别：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/C1RA4mBEoxNDFGl.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217161156859" src="https://s2.loli.net/2022/12/17/C1RA4mBEoxNDFGl.png" /></a></p>
<p>Spring默认的传播级别是<code>PROPAGATION_REQUIRED</code>，那么我们来看看，它是如何传播的，现在我们的<code>Service</code>类中一共存在两个事务，而一个事务方法包含了另一个事务方法：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">TestService</span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Resource</span>
<span class="w">    </span><span class="n">TestMapper</span><span class="w"> </span><span class="n">mapper</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Transactional</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">test2</span><span class="p">();</span><span class="w">   </span><span class="c1">//包含另一个事务</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;我是测试异常！&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">//发生异常时，会回滚另一个事务吗？</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Transactional</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mapper</span><span class="p">.</span><span class="na">insertStudent</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>最后我们得到结果，另一个事务也被回滚了，也就是说，相当于另一个事务直接加入到此事务中，也就是表中所描述的那样。如果单独执行<code>test2()</code>则会开启一个新的事务，而执行<code>test()</code>则会直接让内部的<code>test2()</code>加入到当前事务中。</p>
<p>现在我们将<code>test2()</code>的传播级别设定为<code>SUPPORTS</code>，那么这时如果单独调用<code>test2()</code>方法，并不会以事务的方式执行，当发生异常时，虽然依然存在AOP增强，但是不会进行回滚操作，而现在再调用<code>test()</code>方法，才会以事务的方式执行：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Transactional</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">test2</span><span class="p">();</span>
<span class="p">}</span>

<span class="nd">@Transactional</span><span class="p">(</span><span class="n">propagation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Propagation</span><span class="p">.</span><span class="na">SUPPORTS</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mapper</span><span class="p">.</span><span class="na">insertStudent</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;我是测试异常！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>我们接着来看<code>MANDATORY</code>，它非常严格，如果当前方法并没有在任何事务中进行，会直接出现异常：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Transactional</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">test2</span><span class="p">();</span>
<span class="p">}</span>

<span class="nd">@Transactional</span><span class="p">(</span><span class="n">propagation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Propagation</span><span class="p">.</span><span class="na">MANDATORY</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mapper</span><span class="p">.</span><span class="na">insertStudent</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;我是测试异常！&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>直接运行<code>test2()</code>方法，报错如下：</p>
<div class="highlight"><pre><span></span><code>Exception in thread &quot;main&quot; org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;
    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:362)
    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:595)
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:382)
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)
    at com.sun.proxy.$Proxy29.test2(Unknown Source)
    at com.test.Main.main(Main.java:17)
</code></pre></div>
<p><code>NESTED</code>级别表示如果存在外层事务，则此方法单独创建一个子事务，回滚只会影响到此子事务，实际上就是利用创建Savepoint，然后回滚到此保存点实现的。<code>NEVER</code>级别表示此方法不应该加入到任何事务中，其余类型适用于同时操作多数据源情况下的分布式事务管理，这里暂时不做介绍。</p>
<h3 id="junit">集成JUnit测试<a class="headerlink" href="#junit" title="Permanent link">&para;</a></h3>
<p>既然使用了Spring，那么怎么集成到JUnit中进行测试呢，首先大家能够想到的肯定是：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestMain</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Test</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">(){</span>
<span class="w">        </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">TestConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="n">TestService</span><span class="w"> </span><span class="n">service</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">TestService</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="n">service</span><span class="p">.</span><span class="na">test</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>直接编写一个测试用例即可，但是这样的话，如果我们有很多个测试用例，那么我们不可能每次测试都去创建ApplicationContext吧？我们可以使用<code>@Before</code>添加一个测试前动作来提前配置ApplicationContext，但是这样的话，还是不够简便，能不能有更快速高效的方法呢？</p>
<p>Spring为我们提供了一个Test模块，它会自动集成Junit进行测试，我们可以导入一下依赖：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.junit.jupiter<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>junit-jupiter<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>5.9.0<span class="nt">&lt;/version&gt;</span>
<span class="w">    </span><span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
<span class="w">    </span><span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
<span class="w">    </span><span class="nt">&lt;artifactId&gt;</span>spring-test<span class="nt">&lt;/artifactId&gt;</span>
<span class="w">    </span><span class="nt">&lt;version&gt;</span>6.0.10<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>
<p>这里导入的是JUnit5和SpringTest模块依赖，然后直接在我们的测试类上添加两个注解就可以搞定：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@ExtendWith</span><span class="p">(</span><span class="n">SpringExtension</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
<span class="nd">@ContextConfiguration</span><span class="p">(</span><span class="n">classes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TestConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestMain</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Autowired</span>
<span class="w">    </span><span class="n">TestService</span><span class="w"> </span><span class="n">service</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Test</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">(){</span>
<span class="w">        </span><span class="n">service</span><span class="p">.</span><span class="na">test</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>@ExtendWith</code>是由JUnit提供的注解，等同于旧版本的<code>@RunWith</code>注解，然后使用SpringTest模块提供的<code>@ContextConfiguration</code>注解来表示要加载哪一个配置文件，可以是XML文件也可以是类，我们这里就直接使用类进行加载。</p>
<p>配置完成后，我们可以直接使用<code>@Autowired</code>来进行依赖注入，并且直接在测试方法中使用注入的Bean，现在就非常方便了。</p>
<p>至此，SSM中的其中一个S（Spring）和一个M（Mybatis）就已经学完了，我们还剩下一个SpringMvc需要去学习，下一章，我们将重新回到Web开发，了解在Spring框架的加持下，我们如何更高效地开发Web应用程序。</p>
<hr />
<h2 id="_11">实现原理探究（选学）<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h2>
<p><strong>注意：</strong>本版块难度很大，所有内容都作为选学内容。</p>
<p>如果学习Spring基本内容对你来说已经非常困难了，建议跳过此小节，直接进入MVC阶段的学习，此小节会从源码角度解释Spring的整个运行原理，对初学者来说等同于小学跨越到高中，它并不是必学内容，但是对于个人阅历提升极为重要（推荐完成整个SSM阶段的学习并且加以实战之后再来看此部分），如果你还是觉得自己能够跟上节奏继续深入钻研底层原理，那么现在就开始吧。</p>
<h3 id="beanbean">Bean工厂与Bean定义<a class="headerlink" href="#beanbean" title="Permanent link">&para;</a></h3>
<p>实际上我们之前的所有操作都离不开一个东西，那就是IoC容器，那么它到底是如何实现呢？这一部分我们将详细介绍，首先我们大致了解一下ApplicationContext的加载流程：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/Un6qjPci2uvkL5X.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217162656678" src="https://s2.loli.net/2022/12/17/Un6qjPci2uvkL5X.png" /></a></p>
<p>我们可以看到，整个过程极为复杂，一句话肯定是无法解释的。由于Spring的源码非常庞大，因此我们不可能再像了解其他框架那样直接自底向上逐行干源码了（各位可以自己点开看看，代码量非常多）</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/QXqvO1sGh6d4ZSz.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217162821241" src="https://s2.loli.net/2022/12/17/QXqvO1sGh6d4ZSz.png" /></a></p>
<p>我们只能对几个关键部分进行介绍，在了解这些内容之后，实际上不需要完全阅读所有部分的源码都可以有一个大致的认识。</p>
<p>首先，容器既然要管理Bean，那么肯定需要一个完善的管理机制，实际上，对Bean的管理都是依靠BeanFactory在进行，顾名思义BeanFactory就是对Bean进行生产和管理的工厂，我们可以尝试自己创建和使用BeanFactory对象：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BeanFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="p">();</span><span class="w">  </span><span class="c1">//这是BeanFactory的一个默认实现类</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;获取Bean对象：&quot;</span><span class="o">+</span><span class="n">factory</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;lbwnb&quot;</span><span class="p">));</span><span class="w">  </span><span class="c1">//我们可以直接找工厂获取Bean对象</span>
<span class="p">}</span>
</code></pre></div>
<p>我们可以直接找Bean工厂索要对象，只不过在一开始，工厂并不知道自己需要生产什么，可以生产什么，因此我们直接索要一个工厂不知道的Bean对象，会直接得到：</p>
<p><a class="glightbox" href="https://s2.loli.net/2023/02/14/n54N3iFQX7awHAl.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20230214193208233" src="https://s2.loli.net/2023/02/14/n54N3iFQX7awHAl.png" /></a></p>
<p>我们只有告诉工厂我们要生产什么，怎么生产，工厂才能开工：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="p">();</span><span class="w">  </span><span class="c1">//这是BeanFactory的一个默认实现类</span>

<span class="w">    </span><span class="n">BeanDefinition</span><span class="w"> </span><span class="n">definition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeanDefinitionBuilder</span><span class="w">   </span><span class="c1">//使用BeanDefinitionBuilder快速创建Bean定义</span>
<span class="w">            </span><span class="p">.</span><span class="na">rootBeanDefinition</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">   </span><span class="c1">//Bean的类型</span>
<span class="w">            </span><span class="p">.</span><span class="na">setScope</span><span class="p">(</span><span class="s">&quot;prototype&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1">//设置作用域为原型模式</span>
<span class="w">            </span><span class="p">.</span><span class="na">getBeanDefinition</span><span class="p">();</span><span class="w">     </span><span class="c1">//生成此Bean定义</span>
<span class="w">    </span><span class="n">factory</span><span class="p">.</span><span class="na">registerBeanDefinition</span><span class="p">(</span><span class="s">&quot;lbwnb&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">definition</span><span class="p">);</span><span class="w">   </span><span class="c1">//向工厂注册Bean此定义，并设定Bean的名称</span>

<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;lbwnb&quot;</span><span class="p">));</span><span class="w">  </span><span class="c1">//现在就可以拿到了</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上，我们的ApplicationContext中就维护了一个AutowireCapableBeanFactory对象：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AbstractRefreshableApplicationContext</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">AbstractApplicationContext</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Nullable</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">beanFactory</span><span class="p">;</span><span class="w">   </span><span class="c1">//默认构造后存放在这里的是一个DefaultListableBeanFactory对象</span>

<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="nd">@Override</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ConfigurableListableBeanFactory</span><span class="w"> </span><span class="nf">getBeanFactory</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//getBeanFactory就可以直接得到上面的对象了</span>
<span class="w">     </span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">beanFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">beanFactory</span><span class="p">;</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">beanFactory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&quot;BeanFactory not initialized or already closed - &quot;</span><span class="w"> </span><span class="o">+</span>
<span class="w">              </span><span class="s">&quot;call &#39;refresh&#39; before accessing beans via the ApplicationContext&quot;</span><span class="p">);</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">beanFactory</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>
<p>我们可以尝试获取一下：</p>
<div class="highlight"><pre><span></span><code><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;application.xml&quot;</span><span class="p">);</span>
<span class="c1">//我们可以直接获取此对象</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">getAutowireCapableBeanFactory</span><span class="p">());</span>
</code></pre></div>
<p>正是因为这样，ApplicationContext才具有了管理和生产Bean对象的能力。</p>
<p>不过，我们的配置可能是XML、可能是配置类，那么Spring要如何进行解析，将这些变成对应的BeanDefinition对象呢？使用BeanDefinitionReader就可以：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//比如我们要读取XML配置，我们直接使用XmlBeanDefinitionReader就可以快速进行扫描</span>
<span class="w">    </span><span class="n">XmlBeanDefinitionReader</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">XmlBeanDefinitionReader</span><span class="p">(</span><span class="n">factory</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//加载此XML文件中所有的Bean定义到Bean工厂中</span>
<span class="w">    </span><span class="n">reader</span><span class="p">.</span><span class="na">loadBeanDefinitions</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathResource</span><span class="p">(</span><span class="s">&quot;application.xml&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//可以看到能正常生产此Bean的实例对象</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>因此，针对于不同类型的配置方式，ApplicationContext有着多种实现，其中常用的有：</p>
<ul>
<li>ClassPathXmlApplicationContext：适用于类路径下的XML配置文件。</li>
<li>FileSystemXmlApplicationContext：适用于非类路径下的XML配置文件。</li>
<li>AnnotationConfigApplicationContext：适用于注解配置形式。</li>
</ul>
<p>比如ClassPathXmlApplicationContext在初始化的时候就会创建一个对应的XmlBeanDefinitionReader进行扫描：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Override</span>
<span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">loadBeanDefinitions</span><span class="p">(</span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">beanFactory</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="p">,</span><span class="w"> </span><span class="n">IOException</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// 为给定的BeanFactory创建XmlBeanDefinitionReader便于读取XML中的Bean配置</span>
<span class="w">   </span><span class="n">XmlBeanDefinitionReader</span><span class="w"> </span><span class="n">beanDefinitionReader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">XmlBeanDefinitionReader</span><span class="p">(</span><span class="n">beanFactory</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// 各种配置，忽略掉</span>
<span class="w">   </span><span class="n">beanDefinitionReader</span><span class="p">.</span><span class="na">setEnvironment</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getEnvironment</span><span class="p">());</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="c1">// 配置完成后，直接开始加载XML文件中的Bean定义</span>
<span class="w">   </span><span class="n">loadBeanDefinitions</span><span class="p">(</span><span class="n">beanDefinitionReader</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">loadBeanDefinitions</span><span class="p">(</span><span class="n">XmlBeanDefinitionReader</span><span class="w"> </span><span class="n">reader</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="p">,</span><span class="w"> </span><span class="n">IOException</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Resource</span><span class="o">[]</span><span class="w"> </span><span class="n">configResources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConfigResources</span><span class="p">();</span><span class="w">   </span><span class="c1">//具体加载过程我就不详细介绍了</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">configResources</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">reader</span><span class="p">.</span><span class="na">loadBeanDefinitions</span><span class="p">(</span><span class="n">configResources</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">configLocations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConfigLocations</span><span class="p">();</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">configLocations</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">reader</span><span class="p">.</span><span class="na">loadBeanDefinitions</span><span class="p">(</span><span class="n">configLocations</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>现在，我们就已经知道，Bean实际上是一开始通过BeanDefinitionReader进行扫描，然后将所有Bean以BeanDefinition对象的形式注册到对应的BeanFactory中进行集中管理，而我们使用的ApplicationContext实际上内部就有一个BeanFactory在进行Bean管理，这样容器才拥有了最基本的Bean管理功能。</p>
<p>当然，BeanFactory还可以具有父子关系，其中最关键的作用就是继承父容器中所有的Bean定义，这样的话，如果我们想要创建一个新的BeanFactory并且默认具有其他BeanFactory中所有的Bean定义外加一些其他的，那么就可以采用这种形式，这是很方便的。</p>
<p>我们可以来尝试一下，创建两个工厂：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">factoryParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="p">();</span>
<span class="w">        </span><span class="n">DefaultListableBeanFactory</span><span class="w"> </span><span class="n">factoryChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//在父工厂中注册A</span>
<span class="w">        </span><span class="n">factoryParent</span><span class="p">.</span><span class="na">registerBeanDefinition</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="na">class</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//在子工厂中注册B、C</span>
<span class="w">        </span><span class="n">factoryChild</span><span class="p">.</span><span class="na">registerBeanDefinition</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="na">class</span><span class="p">));</span>
<span class="w">        </span><span class="n">factoryChild</span><span class="p">.</span><span class="na">registerBeanDefinition</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="na">class</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//最后设定子工厂的父工厂</span>
<span class="w">        </span><span class="n">factoryChild</span><span class="p">.</span><span class="na">setParentBeanFactory</span><span class="p">(</span><span class="n">factoryParent</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">A</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">B</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">C</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>现在我们来看看是不是我们想的那样：</p>
<div class="highlight"><pre><span></span><code><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">factoryChild</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="na">class</span><span class="p">));</span><span class="w">  </span><span class="c1">//子工厂不仅能获取到自己的，也可以拿到父工厂的</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">factoryChild</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="na">class</span><span class="p">));</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">factoryChild</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="na">class</span><span class="p">));</span>

<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">factoryParent</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="na">class</span><span class="p">));</span><span class="w">   </span><span class="c1">//注意父工厂不能拿到子工厂的，就像类的继承一样</span>
</code></pre></div>
<p>同样的，我们在使用ApplicationContext时，也可以设定这样的父子关系，效果相同：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">contextParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;parent.xml&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">contextChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="o">[]</span><span class="p">{</span><span class="s">&quot;child.xml&quot;</span><span class="p">},</span><span class="w"> </span><span class="n">contextParent</span><span class="p">);</span><span class="w">  </span><span class="c1">//第一个参数只能用数组，奇怪</span>
<span class="p">}</span>
</code></pre></div>
<p>当然，除了这些功能之外，BeanFactory还提供了很多其他的管理Bean定义的方法，比如移除Bean定义、拷贝Bean定义、销毁单例Bean实例对象等功能，这里就不一一列出了，各位小伙伴自己调用一下测试就可以了，很简单。</p>
<h3 id="bean_2">单例Bean的创建与循环依赖<a class="headerlink" href="#bean_2" title="Permanent link">&para;</a></h3>
<p>前面我们讲解了配置的Bean是如何被读取并加载到容器中的，接着我们来了解一下Bean实例对象是如何被创建并得到的，我们知道，如果要得到一个Bean的实例很简单，通过<code>getBean</code>方法就可以直接拿到了：</p>
<div class="highlight"><pre><span></span><code><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathXmlApplicationContext</span><span class="p">(</span><span class="s">&quot;application.xml&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">));</span><span class="w">   </span><span class="c1">//通过此方法就能快速得到</span>
</code></pre></div>
<p>那么，一个Bean的实例对象到底是如何创建出来的呢？我们还要继续对我们之前讲解的BeanFactory进行深入介绍。</p>
<p>我们可以直接找到BeanFactory接口的一个抽象实现<code>AbstractBeanFactory</code>类，它实现了<code>getBean()</code>方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">getBean</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//套娃开始了，做好准备</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">doGetBean</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Object</span><span class="o">[]</span><span class="p">)</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>那么我们<code>doGetBean()</code>接着来看方法里面干了什么，这个方法比较长，我们分段进行讲解：</p>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">doGetBean</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">requiredType</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">typeCheckOnly</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">transformedBeanName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">   </span><span class="c1">//虽然这里直接传的就是name，但是万一是别名呢，所以还得要解析一下变成原本的Bean名字</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">sharedInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getSingleton</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">   </span><span class="c1">//首先直接获取单例Bean对象</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">beanInstance</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sharedInstance</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//判断是否成功获取到共享的单例对象</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>因为所有的Bean默认都是单例模式，对象只会存在一个，因此它会先调用父类的<code>getSingleton()</code>方法来直接获取单例对象，如果有的话，就可以直接拿到Bean的实例。如果Bean不是单例模式，那么会进入else代码块。这一部分我们先来看单例模式下的处理，其实逻辑非常简单：</p>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">doGetBean</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">requiredType</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">typeCheckOnly</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sharedInstance</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">logger</span><span class="p">.</span><span class="na">isTraceEnabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//这里会判断Bean是否为正在创建状态，为什么会有这种状态呢？我们会在后面进行介绍</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">isSingletonCurrentlyInCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">logger</span><span class="p">.</span><span class="na">trace</span><span class="p">(</span><span class="s">&quot;Returning eagerly cached instance of singleton bean &#39;&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">logger</span><span class="p">.</span><span class="na">trace</span><span class="p">(</span><span class="s">&quot;Returning cached instance of singleton bean &#39;&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;&#39;&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">                </span><span class="c1">//这里getObjectForBeanInstance会进行最终处理</span>
<span class="w">        </span><span class="c1">//因为Bean有两个特殊的类型，工厂Bena和空Bean，所以说需要单独处理</span>
<span class="w">        </span><span class="c1">//如果是普通Bean直接原样返回beanInstance接收到最终结果</span>
<span class="w">        </span><span class="n">beanInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getObjectForBeanInstance</span><span class="p">(</span><span class="n">sharedInstance</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">RootBeanDefinition</span><span class="p">)</span><span class="kc">null</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//最后还会进行一次类型判断，如果都没问题，直接返回beanInstance作为结果，我们就得到Bean的实例对象了</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">adaptBeanInstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">beanInstance</span><span class="p">,</span><span class="w"> </span><span class="n">requiredType</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上整个单例Bean的创建路线还是很清晰的，并没有什么很难理解的地方，在正常情况下，其实就是简单的创建对象实例并返回即可。</p>
<p>其中最关键的是它对于循环依赖的处理。我们发现，在上面的代码中，得到单例对象后，会有一个很特殊的判断<code>isSingletonCurrentlyInCreation</code>，这个是干嘛的？对象不应该直接创建出来吗？为什么会有这种正在创建的状态呢？我们来探究一下。</p>
<p>开始之前先给大家提个问题：</p>
<blockquote>
<p>现在有两个Bean，A和B都是以原型模式进行创建，而A中需要注入B，B中需要注入A，这时就会出现A还未创建完成，就需要B，而B这时也没创建完成，因为B需要A，而A等着B，B又等着A，这样就只能无限循环下去了（就像死锁那种感觉）所以就出现了循环依赖的问题（同理，一个对象注入自己，还有三个对象之间，甚至多个对象之间也会出现这种情况）</p>
</blockquote>
<p>但是，在单例模式下，由于每个Bean只会创建一个实例，只要能够处理好对象之间的引用关系，Spring完全有机会解决单例对象循环依赖的问题。那么单例模式下是如何解决循环依赖问题的呢？</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/17/aRjr1968Lc3BkKH.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221217170912302" src="https://s2.loli.net/2022/12/17/aRjr1968Lc3BkKH.png" /></a></p>
<p>我们回到一开始的<code>getSingleton()</code>方法中，研究一下它到底是如何处理循环依赖的，它是可以自动解决循环依赖问题的：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Nullable</span>
<span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">getSingleton</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">allowEarlyReference</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">singletonObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">singletonObjects</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//先从第一层列表中拿Bean实例，拿到直接返回</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singletonObject</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">isSingletonCurrentlyInCreation</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//如果第一层拿不到，并且已经认定为处于循环状态，看看第二层有没有</span>
<span class="w">        </span><span class="n">singletonObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">earlySingletonObjects</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//要是还是没有，继续往下</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singletonObject</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">allowEarlyReference</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">synchronized</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">singletonObjects</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//加锁再执行一次上述流程</span>
<span class="w">                </span><span class="n">singletonObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">singletonObjects</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singletonObject</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">singletonObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">earlySingletonObjects</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singletonObject</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="c1">//仍然没有获取到实例，只能从singletonFactory中获取了</span>
<span class="w">                        </span><span class="n">ObjectFactory</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">singletonFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ObjectFactory</span><span class="p">)</span><span class="k">this</span><span class="p">.</span><span class="na">singletonFactories</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singletonFactory</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="n">singletonObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">singletonFactory</span><span class="p">.</span><span class="na">getObject</span><span class="p">();</span>
<span class="w">                            </span><span class="c1">//丢进earlySingletonObjects中，下次就可以直接在第二层拿到了</span>
<span class="w">                            </span><span class="k">this</span><span class="p">.</span><span class="na">earlySingletonObjects</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">singletonObject</span><span class="p">);</span>
<span class="w">                            </span><span class="k">this</span><span class="p">.</span><span class="na">singletonFactories</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">singletonObject</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>看起来很复杂，实际上它使用了三级缓存的方式来处理循环依赖的问题，包括：</p>
<ul>
<li>singletonObjects，用于保存实例化、注入、初始化完成的 bean 实例</li>
<li>earlySingletonObjects，用于保存实例化完成的 bean 实例</li>
<li>singletonFactories，在初始创建Bean对象时都会生成一个对应的单例工厂用于获取早期对象</li>
</ul>
<p>我们先来画一个流程图理清整个过程：</p>
<p><a class="glightbox" href="https://s2.loli.net/2022/12/18/xFfUuaozLpiVg96.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20221218150012610" src="https://s2.loli.net/2022/12/18/xFfUuaozLpiVg96.png" /></a></p>
<p>我们在了解这个流程之前，一定要先明确，单例Bean对象的获取，会有哪些结果，首先就是如果我们获取的Bean压根就没在工厂中注册，那得到的结果肯定是null；其次，如果我们获取的Bean已经注册了，那么肯定就可以得到这个单例对象，只是不清楚创建到哪一个阶段了。</p>
<p>现在我们根据上面的流程图，来模拟一下A和B循环依赖的情况：</p>
<p><a class="glightbox" href="https://s2.loli.net/2023/02/14/ezkOUv8Wjrb2tVF.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20230214222056632" src="https://s2.loli.net/2023/02/14/ezkOUv8Wjrb2tVF.png" /></a></p>
<p>有的小伙伴就会有疑问了，看起来似乎两级缓存也可以解决问题啊，干嘛搞三层而且还搞个对象工厂？这不是多此一举吗？实际上这是为了满足Bean的生命周期而做的，通过工厂获取早期对象代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">getEarlyBeanReference</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">exposedObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//这里很关键，会对一些特别的BeanPostProcessor进行处理，比如AOP代理相关的，如果这个Bean是被AOP代理的，我们需要得到的是一个经过AOP代理的对象，而不是直接创建出来的对象，这个过程需要BeanPostProcessor来完成（AOP产生代理对象的逻辑是在属性填充之后，因此只能再加一级进行缓冲）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mbd</span><span class="p">.</span><span class="na">isSynthetic</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">hasInstantiationAwareBeanPostProcessors</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">SmartInstantiationAwareBeanPostProcessor</span><span class="w"> </span><span class="n">bp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">getBeanPostProcessorCache</span><span class="p">().</span><span class="na">smartInstantiationAware</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">exposedObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bp</span><span class="p">.</span><span class="na">getEarlyBeanReference</span><span class="p">(</span><span class="n">exposedObject</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">exposedObject</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们会在后面的部分中详细介绍BeanPostProcessor以及AOP的实现原理，届时各位再回来看就会明白了。</p>
<h3 id="aop_4">后置处理器与AOP<a class="headerlink" href="#aop_4" title="Permanent link">&para;</a></h3>
<p>接着我们来介绍一下<code>PostProcessor</code>，它其实是Spring提供的一种后置处理机制，它可以让我们能够插手Bean、BeanFactory、BeanDefinition的创建过程，相当于进行一个最终的处理，而最后得到的结果（比如Bean实例、Bean定义等）就是经过后置处理器返回的结果，它是整个加载过程的最后一步。</p>
<p>而AOP机制正是通过它来实现的，我们首先来认识一下第一个接口<code>BeanPostProcessor</code>，它相当于Bean初始化的一个后置动作，我们可以直接实现此接口：</p>
<div class="highlight"><pre><span></span><code><span class="c1">//注意它后置处理器也要进行注册</span>
<span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestBeanProcessor</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanPostProcessor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessAfterInitialization</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  </span><span class="c1">//打印bean的名称</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessBeforeInitialization</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">BeanPostProcessor</span><span class="p">.</span><span class="na">super</span><span class="p">.</span><span class="na">postProcessBeforeInitialization</span><span class="p">(</span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>我们发现，此接口中包括两个方法，一个是<code>postProcessAfterInitialization</code>用于在Bean初始化之后进行处理，还有一个<code>postProcessBeforeInitialization</code>用于在Bean初始化之前进行处理，注意这里的初始化不是创建对象，而是调用类的初始化方法，比如：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestBeanProcessor</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanPostProcessor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessAfterInitialization</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是之后：&quot;</span><span class="o">+</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">   </span><span class="c1">//这里返回的Bean相当于最终的结果了，我们依然能够插手修改，这里返回之后是什么就是什么了</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">postProcessBeforeInitialization</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是之前：&quot;</span><span class="o">+</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bean</span><span class="p">;</span><span class="w">   </span><span class="c1">//这里返回的Bean会交给下一个阶段，也就是初始化方法</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestServiceImpl</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">TestService</span><span class="p">{</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">TestServiceImpl</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是构造方法&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@PostConstruct</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是初始化方法&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">TestMapper</span><span class="w"> </span><span class="n">mapper</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Autowired</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setMapper</span><span class="p">(</span><span class="n">TestMapper</span><span class="w"> </span><span class="n">mapper</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是依赖注入&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">mapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapper</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>而TestServiceImpl的加载顺序为：</p>
<div class="highlight"><pre><span></span><code>我是构造方法
我是依赖注入
我是之前：testServiceImpl
我是初始化方法
我是之后：testServiceImpl
</code></pre></div>
<p>现在我们再来总结一下一个Bean的加载流程：</p>
<p>[Bean定义]首先扫描Bean，加载Bean定义 -&gt; [依赖注入]根据Bean定义通过反射创建Bean实例 -&gt; [依赖注入]进行依赖注入（顺便解决循环依赖问题）-&gt; [初始化Bean]BeanPostProcessor的初始化之前方法 -&gt; [初始化Bean]Bean初始化方法 -&gt; [初始化Bean]BeanPostProcessor的初始化之后方法 -&gt; [完成]最终得到的Bean加载完成的实例</p>
<p>利用这种机制，理解Aop的实现过程就非常简单了，AOP实际上也是通过这种机制实现的，它的实现类是<code>AnnotationAwareAspectJAutoProxyCreator</code>，而它就是在最后对Bean进行了代理，因此最后我们得到的结果实际上就是一个动态代理的对象（有关详细实现过程，这里就不进行列举了，感兴趣的可以继续深入）因此，实际上之前设计的三层缓存，都是由于需要处理AOP设计的，因为在Bean创建得到最终对象之前，很有可能会被PostProcessor给偷梁换柱！</p>
<p>那么肯定有人有疑问了，这个类没有被注册啊，那按理说它不应该参与到Bean的初始化流程中的，为什么它直接就被加载了呢？</p>
<p>还记得<code>@EnableAspectJAutoProxy</code>吗？我们来看看它是如何定义就知道了：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Target</span><span class="p">({</span><span class="n">ElementType</span><span class="p">.</span><span class="na">TYPE</span><span class="p">})</span>
<span class="nd">@Retention</span><span class="p">(</span><span class="n">RetentionPolicy</span><span class="p">.</span><span class="na">RUNTIME</span><span class="p">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Import</span><span class="p">({</span><span class="n">AspectJAutoProxyRegistrar</span><span class="p">.</span><span class="na">class</span><span class="p">})</span>
<span class="kd">public</span><span class="w"> </span><span class="nd">@interface</span><span class="w"> </span><span class="n">EnableAspectJAutoProxy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">proxyTargetClass</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">exposeProxy</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们发现它使用了<code>@Import</code>来注册<code>AspectJAutoProxyRegistrar</code>，那么这个类又是什么呢，我们接着来看：</p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">AspectJAutoProxyRegistrar</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ImportBeanDefinitionRegistrar</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">AspectJAutoProxyRegistrar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerBeanDefinitions</span><span class="p">(</span><span class="n">AnnotationMetadata</span><span class="w"> </span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//注册AnnotationAwareAspectJAutoProxyCreator到容器中</span>
<span class="w">        </span><span class="n">AopConfigUtils</span><span class="p">.</span><span class="na">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
<span class="w">        </span><span class="n">AnnotationAttributes</span><span class="w"> </span><span class="n">enableAspectJAutoProxy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">attributesFor</span><span class="p">(</span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">EnableAspectJAutoProxy</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enableAspectJAutoProxy</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enableAspectJAutoProxy</span><span class="p">.</span><span class="na">getBoolean</span><span class="p">(</span><span class="s">&quot;proxyTargetClass&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">AopConfigUtils</span><span class="p">.</span><span class="na">forceAutoProxyCreatorToUseClassProxying</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enableAspectJAutoProxy</span><span class="p">.</span><span class="na">getBoolean</span><span class="p">(</span><span class="s">&quot;exposeProxy&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">AopConfigUtils</span><span class="p">.</span><span class="na">forceAutoProxyCreatorToExposeProxy</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>它实现了接口，这个接口也是Spring提供的一种Bean加载机制，它支持直接向容器中添加Bean定义，容器也会加载这个Bean：</p>
<ul>
<li>ImportBeanDefinitionRegistrar类只能通过其他类@Import的方式来加载，通常是启动类或配置类。</li>
<li>使用@Import，如果括号中的类是ImportBeanDefinitionRegistrar的实现类，则会调用接口中方法（一般用于注册Bean）</li>
<li>实现该接口的类拥有注册bean的能力。</li>
</ul>
<p>我们可以看到此接口提供了一个<code>BeanDefinitionRegistry</code>正是用于注册Bean的定义的。</p>
<p>因此，当我们打上了<code>@EnableAspectJAutoProxy</code>注解之后，首先会通过<code>@Import</code>加载AspectJAutoProxyRegistrar，然后调用其<code>registerBeanDefinitions</code>方法，然后使用工具类注册AnnotationAwareAspectJAutoProxyCreator到容器中，这样在每个Bean创建之后，如果需要使用AOP，那么就会通过AOP的后置处理器进行处理，最后返回一个代理对象。</p>
<p>我们也可以尝试编写一个自己的ImportBeanDefinitionRegistrar实现，首先编写一个测试Bean：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestBean</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@PostConstruct</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(){</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我被初始化了！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestBeanDefinitionRegistrar</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ImportBeanDefinitionRegistrar</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerBeanDefinitions</span><span class="p">(</span><span class="n">AnnotationMetadata</span><span class="w"> </span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">BeanDefinition</span><span class="w"> </span><span class="n">definition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeanDefinitionBuilder</span><span class="p">.</span><span class="na">rootBeanDefinition</span><span class="p">(</span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">).</span><span class="na">getBeanDefinition</span><span class="p">();</span>
<span class="w">        </span><span class="n">registry</span><span class="p">.</span><span class="na">registerBeanDefinition</span><span class="p">(</span><span class="s">&quot;lbwnb&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">definition</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>观察控制台输出，成功加载Bean实例。</p>
<p>与<code>BeanPostProcessor</code>差不多的还有<code>BeanFactoryPostProcessor</code>，它和前者一样，也是用于我们自己处理后置动作的，不过这里是用于处理BeanFactory加载的后置动作，<code>BeanDefinitionRegistryPostProcessor</code>直接继承自<code>BeanFactoryPostProcessor</code>，并且还添加了新的动作<code>postProcessBeanDefinitionRegistry</code>，你可以在这里动态添加Bean定义或是修改已经存在的Bean定义，这里我们就直接演示<code>BeanDefinitionRegistryPostProcessor</code>的实现：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestDefinitionProcessor</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanDefinitionRegistryPostProcessor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postProcessBeanDefinitionRegistry</span><span class="p">(</span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是Bean定义后置处理！&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">BeanDefinition</span><span class="w"> </span><span class="n">definition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeanDefinitionBuilder</span><span class="p">.</span><span class="na">rootBeanDefinition</span><span class="p">(</span><span class="n">TestBean</span><span class="p">.</span><span class="na">class</span><span class="p">).</span><span class="na">getBeanDefinition</span><span class="p">();</span>
<span class="w">        </span><span class="n">registry</span><span class="p">.</span><span class="na">registerBeanDefinition</span><span class="p">(</span><span class="s">&quot;lbwnb&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">definition</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postProcessBeanFactory</span><span class="p">(</span><span class="n">ConfigurableListableBeanFactory</span><span class="w"> </span><span class="n">configurableListableBeanFactory</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是Bean工厂后置处理！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>在这里注册Bean定义其实和之前那种方法效果一样。</p>
<p>最后，我们再完善一下Bean加载流程（加粗部分是新增的）：</p>
<p>[Bean定义]首先扫描Bean，加载Bean定义 -&gt; <strong>[Bean定义]Bean定义和Bean工厂后置处理</strong> -&gt; [依赖注入]根据Bean定义通过反射创建Bean实例 -&gt; [依赖注入]进行依赖注入（顺便解决循环依赖问题）-&gt; [初始化Bean]BeanPostProcessor的初始化之前方法 -&gt; [初始化Bean]Bean初始化方法 -&gt; [初始化Bean]BeanPostProcessor的初始化之前后方法 -&gt; [完成]最终得到的Bean加载完成的实例</p>
<h3 id="_12">应用程序上下文详解<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>前面我们详细介绍了BeanFactory是如何工作的，接着我们来研究一下ApplicationContext的内部，实际上我们真正在项目中使用的就是ApplicationContext的实现，那么它又是如何工作的呢。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ApplicationContext</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">EnvironmentCapable</span><span class="p">,</span><span class="w"> </span><span class="n">ListableBeanFactory</span><span class="p">,</span><span class="w"> </span><span class="n">HierarchicalBeanFactory</span><span class="p">,</span><span class="w"> </span><span class="n">MessageSource</span><span class="p">,</span><span class="w"> </span><span class="n">ApplicationEventPublisher</span><span class="p">,</span><span class="w"> </span><span class="n">ResourcePatternResolver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Nullable</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="nf">getId</span><span class="p">();</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="nf">getApplicationName</span><span class="p">();</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="nf">getDisplayName</span><span class="p">();</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="nf">getStartupDate</span><span class="p">();</span>
<span class="w">    </span><span class="nd">@Nullable</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="nf">getParent</span><span class="p">();</span>
<span class="w">    </span><span class="n">AutowireCapableBeanFactory</span><span class="w"> </span><span class="nf">getAutowireCapableBeanFactory</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">IllegalStateException</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>它本身是一个接口，同时集成了多种类型的BeanFactory接口，说明它应该具有这些BeanFactory的能力，实际上我们在前面已经提到过，ApplicationContext是依靠内部维护的BeanFactory对象来完成这些功能的，并不是它本身就实现了这些功能。</p>
<p>这里我们就先从构造方法开始走起，以我们常用的AnnotationConfigApplicationContext为例：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="nf">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="p">...</span><span class="w"> </span><span class="n">componentClasses</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">();</span><span class="w">                      </span><span class="c1">//1. 首先会调用自己的无参构造</span>
<span class="w">        </span><span class="n">register</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">);</span><span class="w">  </span><span class="c1">//2. 然后注册我们传入的配置类</span>
<span class="w">        </span><span class="n">refresh</span><span class="p">();</span><span class="w">                   </span><span class="c1">//3. 最后进行刷新操作（关键）</span>
<span class="p">}</span>
</code></pre></div>
<p>先来看第一步：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="nf">GenericApplicationContext</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//父类首先初始化内部维护的BeanFactory对象</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">beanFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultListableBeanFactory</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="nf">AnnotationConfigApplicationContext</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">createAnnotatedBeanDefReader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getApplicationStartup</span><span class="p">().</span><span class="na">start</span><span class="p">(</span><span class="s">&quot;spring.context.annotated-bean-reader.create&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//创建AnnotatedBeanDefinitionReader对象，用于后续处理 @Bean 注解</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotatedBeanDefinitionReader</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">createAnnotatedBeanDefReader</span><span class="p">.</span><span class="na">end</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//创建ClassPathBeanDefinitionScanner对象，用于扫描类路径上的Bean</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">scanner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathBeanDefinitionScanner</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这样，AnnotationConfigApplicationContext的基本内容就初始化好了，不过这里结束之后会将ConfigurationClassPostProcessor后置处理器加入到BeanFactory中，它继承自BeanFactoryPostProcessor，也就是说一会会在BeanFactory初始化完成之后进行后置处理：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="nf">AnnotatedBeanDefinitionReader</span><span class="p">(</span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">Environment</span><span class="w"> </span><span class="n">environment</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="na">notNull</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;BeanDefinitionRegistry must not be null&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="na">notNull</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Environment must not be null&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">registry</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">conditionEvaluator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConditionEvaluator</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">environment</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//这里注册了注解处理配置相关的后置处理器</span>
<span class="w">        </span><span class="n">AnnotationConfigUtils</span><span class="p">.</span><span class="na">registerAnnotationConfigProcessors</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">registry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上这个后置处理器的主要目的就是为了读取配置类中的各种Bean定义以及其他注解，比如@Import、@ComponentScan等。</p>
<p>同时这里也会注册一个AutowiredAnnotationBeanPostProcessor后置处理器到BeanFactory，它继承自BeanPostProcessor，用于处理后续生成的Bean对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value这种注解，用于自动注入，这里就不深入讲解具体实现了。</p>
<p>所以，第一步结束之后，就会有这两个关键的后置处理器放在容器中：</p>
<p><a class="glightbox" href="https://s2.loli.net/2023/07/19/uY4zwEhArUMfP2d.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20230719152546148" src="https://s2.loli.net/2023/07/19/uY4zwEhArUMfP2d.png" /></a></p>
<p>接着是第二步，注册配置类：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Override</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="p">...</span><span class="w"> </span><span class="n">componentClasses</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="na">notEmpty</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;At least one component class must be specified&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">registerComponentClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getApplicationStartup</span><span class="p">().</span><span class="na">start</span><span class="p">(</span><span class="s">&quot;spring.context.component-classes.register&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">.</span><span class="na">tag</span><span class="p">(</span><span class="s">&quot;classes&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">toString</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">));</span>
<span class="w">    </span><span class="c1">//使用我们上面创建的Reader注册配置类</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">reader</span><span class="p">.</span><span class="na">register</span><span class="p">(</span><span class="n">componentClasses</span><span class="p">);</span>
<span class="w">        </span><span class="n">registerComponentClass</span><span class="p">.</span><span class="na">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>现在配置类已经成功注册到IoC容器中了，我们接着来看第三步，到目前为止，我们已知的仅仅是注册了配置类的Bean，而刷新操作就是配置所有Bean的关键部分了，刷新操作是在 AbstractApplicationContext 中实现的：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Override</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">refresh</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="p">,</span><span class="w"> </span><span class="n">IllegalStateException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">startupShutdownMonitor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">contextRefresh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">applicationStartup</span><span class="p">.</span><span class="na">start</span><span class="p">(</span><span class="s">&quot;spring.context.refresh&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// 准备当前应用程序上下文，进行刷新、设置启动事件和活动标志以及执行其他初始化</span>
<span class="w">            </span><span class="n">prepareRefresh</span><span class="p">();</span>
<span class="w">            </span><span class="c1">// 这个方法由子类实现，对内部维护的BeanFactory进行刷新操作，然后返回这个BeanFactory</span>
<span class="w">            </span><span class="n">ConfigurableListableBeanFactory</span><span class="w"> </span><span class="n">beanFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obtainFreshBeanFactory</span><span class="p">();</span>
<span class="w">            </span><span class="c1">// 初始化配置Bean工厂，比如一些会用到的类加载器和后置处理器。</span>
<span class="w">            </span><span class="n">prepareBeanFactory</span><span class="p">(</span><span class="n">beanFactory</span><span class="p">);</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 由子类实现对BeanFactory的其他后置处理，目前没有看到有实现</span>
<span class="w">                </span><span class="n">postProcessBeanFactory</span><span class="p">(</span><span class="n">beanFactory</span><span class="p">);</span>
<span class="w">                </span><span class="n">StartupStep</span><span class="w"> </span><span class="n">beanPostProcess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">applicationStartup</span><span class="p">.</span><span class="na">start</span><span class="p">(</span><span class="s">&quot;spring.context.beans.post-process&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="c1">// 实例化并调用所有注册的 BeanFactoryPostProcessor 类型的Bean</span>
<span class="w">        </span><span class="c1">// 这一步中，上面提到的BeanFactoryPostProcessor就开始工作了，比如包扫描、解析Bean配置等</span>
<span class="w">        </span><span class="c1">// 这一步结束之后，包扫描到的其他Bean就注册到BeanFactory中了</span>
<span class="w">                </span><span class="n">invokeBeanFactoryPostProcessors</span><span class="p">(</span><span class="n">beanFactory</span><span class="p">);</span>
<span class="w">                </span><span class="c1">// 实例化并注册所有 BeanPostProcessor 类型的 Bean，不急着执行</span>
<span class="w">                </span><span class="n">registerBeanPostProcessors</span><span class="p">(</span><span class="n">beanFactory</span><span class="p">);</span>
<span class="w">                </span><span class="n">beanPostProcess</span><span class="p">.</span><span class="na">end</span><span class="p">();</span>
<span class="w">                </span><span class="n">initMessageSource</span><span class="p">();</span>
<span class="w">                </span><span class="n">initApplicationEventMulticaster</span><span class="p">();</span>
<span class="w">                </span><span class="c1">// 依然是提供给子类实现的，目的是用于处理一些其他比较特殊的Bean，目前似乎也没看到有实现</span>
<span class="w">                </span><span class="n">onRefresh</span><span class="p">();</span>
<span class="w">                </span><span class="c1">// 注册所有的监听器</span>
<span class="w">                </span><span class="n">registerListeners</span><span class="p">();</span>
<span class="w">                </span><span class="c1">// 将剩余所有非懒加载单例Bean全部实例化</span>
<span class="w">                </span><span class="n">finishBeanFactoryInitialization</span><span class="p">(</span><span class="n">beanFactory</span><span class="p">);</span>
<span class="w">                </span><span class="n">finishRefresh</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BeansException</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">...</span>
<span class="w">                </span><span class="c1">// 发现异常直接销毁所有Bean</span>
<span class="w">                </span><span class="n">destroyBeans</span><span class="p">();</span>
<span class="w">                </span><span class="c1">// 取消本次刷新操作，重置标记</span>
<span class="w">                </span><span class="n">cancelRefresh</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="w">                </span><span class="c1">// 继续往上抛异常</span>
<span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">resetCommonCaches</span><span class="p">();</span>
<span class="w">                </span><span class="n">contextRefresh</span><span class="p">.</span><span class="na">end</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>所以，现在流程就很清晰了，实际上最主要的就是<code>refresh</code>方法，它从初始化到实例化所有的Bean整个流程都已经完成，在这个方法结束之后，整个IoC容器基本就可以正常使用了。</p>
<p>我们继续来研究一下<code>finishBeanFactoryInitialization</code>方法，看看它是怎么加载所有Bean的：</p>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">finishBeanFactoryInitialization</span><span class="p">(</span><span class="n">ConfigurableListableBeanFactory</span><span class="w"> </span><span class="n">beanFactory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="n">beanFactory</span><span class="p">.</span><span class="na">preInstantiateSingletons</span><span class="p">();</span><span class="w">   </span><span class="c1">//套娃</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">preInstantiateSingletons</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="c1">// 列出全部bean名称</span>
<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">beanNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">beanDefinitionNames</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 开始初始化所有Bean</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">beanNames</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//得到Bean定义</span>
<span class="w">            </span><span class="n">RootBeanDefinition</span><span class="w"> </span><span class="n">bd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMergedLocalBeanDefinition</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">      </span><span class="c1">//Bean不能是抽象类、不能是非单例模式、不能是懒加载的</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">.</span><span class="na">isAbstract</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bd</span><span class="p">.</span><span class="na">isSingleton</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">bd</span><span class="p">.</span><span class="na">isLazyInit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//针对于Bean和FactoryBean分开进行处理</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isFactoryBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getBean</span><span class="p">(</span><span class="n">FACTORY_BEAN_PREFIX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bean</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">SmartFactoryBean</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">smartFactoryBean</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">smartFactoryBean</span><span class="p">.</span><span class="na">isEagerInit</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">getBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">getBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">);</span><span class="w">  </span><span class="c1">//最后都是通过调用getBean方法来初始化实例，这里就跟我们之前讲的连起来了</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>至此，关于Spring容器核心加载流程，我们就探究完毕了，实际 单易懂，就是代码量太大了。在后续的SpringBoot阶段，我们还会继续深挖Spring的某些机制的具体实现细节。</p>
<h3 id="mybatis_3">Mybatis整合原理<a class="headerlink" href="#mybatis_3" title="Permanent link">&para;</a></h3>
<p>通过之前的了解，我们再来看Mybatis的<code>@MapperScan</code>是如何实现的，现在理解起来就非常简单了。</p>
<p>我们可以直接打开查看：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Retention</span><span class="p">(</span><span class="n">RetentionPolicy</span><span class="p">.</span><span class="na">RUNTIME</span><span class="p">)</span>
<span class="nd">@Target</span><span class="p">({</span><span class="n">ElementType</span><span class="p">.</span><span class="na">TYPE</span><span class="p">})</span>
<span class="nd">@Documented</span>
<span class="nd">@Import</span><span class="p">({</span><span class="n">MapperScannerRegistrar</span><span class="p">.</span><span class="na">class</span><span class="p">})</span>
<span class="nd">@Repeatable</span><span class="p">(</span><span class="n">MapperScans</span><span class="p">.</span><span class="na">class</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="nd">@interface</span><span class="w"> </span><span class="n">MapperScan</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="nf">value</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="nf">basePackages</span><span class="p">()</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>
<p>我们发现，和Aop一样，它也是通过Registrar机制，通过<code>@Import</code>来进行Bean的注册，我们来看看<code>MapperScannerRegistrar</code>是个什么东西，关键代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">registerBeanDefinitions</span><span class="p">(</span><span class="n">AnnotationMetadata</span><span class="w"> </span><span class="n">annoMeta</span><span class="p">,</span><span class="w"> </span><span class="n">AnnotationAttributes</span><span class="w"> </span><span class="n">annoAttrs</span><span class="p">,</span><span class="w"> </span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BeanDefinitionBuilder</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeanDefinitionBuilder</span><span class="p">.</span><span class="na">genericBeanDefinition</span><span class="p">(</span><span class="n">MapperScannerConfigurer</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">builder</span><span class="p">.</span><span class="na">addPropertyValue</span><span class="p">(</span><span class="s">&quot;processPropertyPlaceHolders&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>虽然很长很多，但是这些代码都是在添加一些Bean定义的属性，而最关键的则是最上方的<code>MapperScannerConfigurer</code>，Mybatis将其Bean信息注册到了容器中，那么这个类又是干嘛的呢？</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MapperScannerConfigurer</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanDefinitionRegistryPostProcessor</span><span class="p">,</span><span class="w"> </span><span class="n">InitializingBean</span><span class="p">,</span><span class="w"> </span><span class="n">ApplicationContextAware</span><span class="p">,</span><span class="w"> </span><span class="n">BeanNameAware</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">basePackage</span><span class="p">;</span>
</code></pre></div>
<p>它实现了BeanDefinitionRegistryPostProcessor，也就是说它为Bean信息加载提供了后置处理，我们接着来看看它在Bean信息后置处理中做了什么：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postProcessBeanDefinitionRegistry</span><span class="p">(</span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">processPropertyPlaceHolders</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">processPropertyPlaceHolders</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//初始化类路径Mapper扫描器，它相当于是一个工具类，可以快速扫描出整个包下的类定义信息</span>
<span class="w">    </span><span class="c1">//ClassPathMapperScanner是Mybatis自己实现的一个扫描器，修改了一些扫描规则</span>
<span class="w">    </span><span class="n">ClassPathMapperScanner</span><span class="w"> </span><span class="n">scanner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ClassPathMapperScanner</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setAddToConfig</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">addToConfig</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setAnnotationClass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">annotationClass</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setMarkerInterface</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">markerInterface</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setSqlSessionFactory</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">sqlSessionFactory</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setSqlSessionTemplate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">sqlSessionTemplate</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setSqlSessionFactoryBeanName</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">sqlSessionFactoryBeanName</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setSqlSessionTemplateBeanName</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">sqlSessionTemplateBeanName</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setResourceLoader</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">applicationContext</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setBeanNameGenerator</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">nameGenerator</span><span class="p">);</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">setMapperFactoryBeanClass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">mapperFactoryBeanClass</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">StringUtils</span><span class="p">.</span><span class="na">hasText</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">lazyInitialization</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">scanner</span><span class="p">.</span><span class="na">setLazyInitialization</span><span class="p">(</span><span class="n">Boolean</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">lazyInitialization</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">StringUtils</span><span class="p">.</span><span class="na">hasText</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">defaultScope</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">scanner</span><span class="p">.</span><span class="na">setDefaultScope</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">defaultScope</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//添加过滤器，这里会配置为所有的接口都能被扫描（因此即使你不添加@Mapper注解都能够被扫描并加载）</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">registerFilters</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//开始扫描</span>
<span class="w">    </span><span class="n">scanner</span><span class="p">.</span><span class="na">scan</span><span class="p">(</span><span class="n">StringUtils</span><span class="p">.</span><span class="na">tokenizeToStringArray</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">basePackage</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;,; \t\n&quot;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>开始扫描后，会调用<code>doScan()</code>方法，我们接着来看（这是<code>ClassPathMapperScanner</code>中的扫描方法）：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">doScan</span><span class="p">(</span><span class="n">String</span><span class="p">...</span><span class="w"> </span><span class="n">basePackages</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">BeanDefinitionHolder</span><span class="o">&gt;</span><span class="w"> </span><span class="n">beanDefinitions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">super</span><span class="p">.</span><span class="na">doScan</span><span class="p">(</span><span class="n">basePackages</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//首先从包中扫描所有的Bean定义</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">beanDefinitions</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">LOGGER</span><span class="p">.</span><span class="na">warn</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;No MyBatis mapper was found in &#39;&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">toString</span><span class="p">(</span><span class="n">basePackages</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;&#39; package. Please check your configuration.&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//处理所有的Bean定义，实际上就是生成对应Mapper的代理对象，并注册到容器中</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">processBeanDefinitions</span><span class="p">(</span><span class="n">beanDefinitions</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//最后返回所有的Bean定义集合</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">beanDefinitions</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>通过断点我们发现，最后处理得到的Bean定义发现此Bean是一个MapperFactoryBean，它不同于普通的Bean，FactoryBean相当于为普通的Bean添加了一层外壳，它并不是依靠Spring直接通过反射创建，而是使用接口中的方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">FactoryBean</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">OBJECT_TYPE_ATTRIBUTE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;factoryBeanObjectType&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Nullable</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">getObject</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Nullable</span>
<span class="w">    </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="nf">getObjectType</span><span class="p">();</span>

<span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isSingleton</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>通过<code>getObject()</code>方法，就可以获取到Bean的实例了。</p>
<p>注意这里一定要区分FactoryBean和BeanFactory的概念：</p>
<ul>
<li>BeanFactory是个Factory，也就是 IOC 容器或对象工厂，所有的 Bean 都是由 BeanFactory( 也就是 IOC 容器 ) 来进行管理。</li>
<li>FactoryBean是一个能生产或者修饰生成对象的工厂Bean(本质上也是一个Bean)，可以在BeanFactory（IOC容器）中被管理，所以它并不是一个简单的Bean。当使用容器中factory bean的时候，该容器不会返回factory bean本身，而是返回其生成的对象。要想获取FactoryBean的实现类本身，得在getBean(String BeanName)中的BeanName之前加上&amp;,写成getBean(String &amp;BeanName)。</li>
</ul>
<p>我们也可以自己编写一个实现：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Component</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestFb</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">FactoryBean</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Student</span><span class="w"> </span><span class="nf">getObject</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;获取了学生&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="nf">getObjectType</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Student</span><span class="p">.</span><span class="na">class</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&quot;项目正在启动...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">TestConfiguration</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;&amp;test&quot;</span><span class="p">));</span><span class="w">   </span><span class="c1">//得到FactoryBean本身（得加个&amp;搞得像C语言指针一样）</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">getBean</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">));</span><span class="w">   </span><span class="c1">//得到FactoryBean调用getObject()之后的结果</span>
<span class="p">}</span>
</code></pre></div>
<p>因此，实际上我们的Mapper最终就以FactoryBean的形式，被注册到容器中进行加载了：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">getObject</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getSqlSession</span><span class="p">().</span><span class="na">getMapper</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">mapperInterface</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这样，整个Mybatis的<code>@MapperScan</code>的原理就全部解释完毕了。</p>
<p>在了解完了Spring的底层原理之后，我们其实已经完全可以根据这些实现原理来手写一个Spring框架了。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../Mybatis/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Mybatis">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Mybatis
              </div>
            </div>
          </a>
        
        
          
          <a href="../SSM%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89SpringSecurity%E5%9F%BA%E7%A1%80/" class="md-footer__link md-footer__link--next" aria-label="Next: SSM笔记（三）SpringSecurity基础">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                SSM笔记（三）SpringSecurity基础
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": ["navigation.footer", "navigation.instant", "navigation.instant.preview", "navigation.tabs", "navigation.top", "navigation.tracking", "navigation.tabs.sticky", "content.code.copy"], "search": "../../../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
        <script src="../../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>